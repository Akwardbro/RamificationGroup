import RamificationGroup.Valued.Hom.Lift
import RamificationGroup.ForMathlib.Algebra.Algebra.Tower
import LocalClassFieldTheory.LocalField.Basic
import RamificationGroup.ForMathlib.Algebra.Algebra.PowerBasis
import RamificationGroup.Valued.AlgebraicInstances
import RamificationGroup.Valuation.Extension
import RamificationGroup.Valued.Hom.ValExtension
import RamificationGroup.Valued.AlgebraicInstances
/-
# Lower Numbering Ramification Group

## Main Definitions

## Main Theorem

## TODO

prove theorems using Bichang's preparation in section SeparatedExhausive

rename theorems, many theorem should be named as LowerRamificationGroup.xxx, not lowerRamificationGroup_xxx

-/

open DiscreteValuation Valued Valuation

section general_algebra

instance instAlgebraFiniteTypeToIsNoetherian (R A : Type*) [CommSemiring R] [Semiring A] [Algebra R A] [IsNoetherian R A] :
  Algebra.FiniteType R A where
    out := by
      apply Subalgebra.fg_of_fg_toSubmodule
      rw [Algebra.top_toSubmodule]
      apply isNoetherian_def.mp
      assumption

end general_algebra

-- <-1 decomposition group
-- >= -1 decompositiongroup and v (s x - x) ‚â§ 1
section def_lower_rami_grp

variable (R S : Type*) {ŒìR : outParam Type*} [CommRing R] [Ring S] [vS : Valued S ‚Ñ§‚Çò‚ÇÄ] [Algebra R S]

def lowerRamificationGroup (u : ‚Ñ§) : Subgroup (S ‚âÉ‚Çê[R] S) where
    carrier := {s | s ‚àà decompositionGroup R S ‚àß ‚àÄ x : vS.v.integer, Valued.v (s x - x) ‚â§ .coe (.ofAdd (- u - 1))}
    mul_mem' {a} {b} ha hb := by
      constructor
      ¬∑ exact mul_mem ha.1 hb.1
      ¬∑ intro x
        calc
          _ = v (a (b x) - x) := rfl
          _ = v ((a (b x) - b x) + (b x - x)) := by congr; simp
          _ ‚â§ max (v (a (b x) - b x)) (v (b x - x)) := Valuation.map_add _ _ _
          _ ‚â§ max (.coe (.ofAdd (- u - 1))) (.coe (.ofAdd (- u - 1))) := by
            apply max_le_max
            ¬∑ exact ha.2 ‚ü®b x, (val_map_le_one_iff hb.1 x).mpr x.2‚ü©
            ¬∑ exact hb.2 x
          _ = _ := max_self _
    one_mem' := by
      constructor
      ¬∑ exact one_mem _
      ¬∑ simp only [AlgEquiv.one_apply, sub_self, _root_.map_zero, ofAdd_sub, ofAdd_neg, zero_le',
        Subtype.forall, implies_true, forall_const]
    inv_mem' {s} hs := by
      constructor
      ¬∑ exact inv_mem hs.1
      intro a
      calc
      _ = v (s‚Åª¬π a - a) := rfl
      _ = v ( s‚Åª¬π a - s (s‚Åª¬π a) ) := by
        congr 1
        simp only [sub_right_inj]
        exact (EquivLike.apply_inv_apply s ‚Üëa).symm
      _ = v ( s (s‚Åª¬π a) - s ‚Åª¬π a) := by
        rw [‚Üê Valuation.map_neg]
        congr
        simp only [neg_sub]
      _ ‚â§ _ := hs.2 ‚ü®s‚Åª¬π a, (val_map_le_one_iff (f := (s.symm : S ‚Üí+* S))
        (Valuation.IsEquiv_comap_symm hs.1) a.1).mpr a.2‚ü©

scoped [Valued] notation:max " G(" S:max "/" R:max ")_[" u:max "] " => lowerRamificationGroup R S u

theorem lowerRamificationGroup.antitone : Antitone (lowerRamificationGroup R S) := by
  intro a b hab
  simp only [lowerRamificationGroup, ofAdd_sub, ofAdd_neg, Subtype.forall, Subgroup.mk_le_mk,
    Set.setOf_subset_setOf, and_imp]
  rintro s hs1 hs2
  constructor
  ¬∑ exact hs1
  ¬∑ intro y hy
    apply le_trans (hs2 y hy)
    simp only [WithZero.coe_le_coe, div_le_iff_le_mul, div_mul_cancel, inv_le_inv_iff,
      Multiplicative.ofAdd_le]
    exact hab

end def_lower_rami_grp

instance Valuation.instNonemptyToValuation {R Œì‚ÇÄ: Type*} [Ring R] [LinearOrderedCommGroupWithZero Œì‚ÇÄ] (v : Valuation R Œì‚ÇÄ): Nonempty v.integer := Zero.instNonempty

section autCongr

variable {R S S': Type*} {ŒìR : outParam Type*} [CommRing R] [Ring S] [Ring S'] [vS : Valued S ‚Ñ§‚Çò‚ÇÄ] [vS : Valued S' ‚Ñ§‚Çò‚ÇÄ] [Algebra R S] [Algebra R S']

#check comap
--if f is a R-algebra isom of S and S', f preserves the valuation, then s ‚àà G(S/R)_[u] if and only if F s ‚àà G(S'/R)_[u], where F : Gal(S/R) ‚Üí Gal(S'/R), F(œÉ)(s') = œÉ(f‚Åª¬π(s')).
--the u-th lower ramification groups of two isomorphic ring extensions are isomorphic for all u ‚àà ‚Ñ§.
theorem autCongr_mem_lowerRamificationGroup_iff {f : S ‚âÉ‚Çê[R] S'} (hf : ‚àÄ a : S, v a = v (f a)) (s : S ‚âÉ‚Çê[R] S) (u : ‚Ñ§) : s ‚àà G(S/R)_[u] ‚Üî (AlgEquiv.autCongr f s : S' ‚âÉ‚Çê[R] S') ‚àà G(S'/R)_[u] := by
  have hf' : ‚àÄ a : S', v (f.symm a) = v a := by
    intro a
    rw [hf (f.symm a), AlgEquiv.apply_symm_apply]
  simp only [lowerRamificationGroup, ofAdd_sub, ofAdd_neg, Subtype.forall, Subgroup.mem_mk,
    Set.mem_setOf_eq, AlgEquiv.autCongr_apply, AlgEquiv.trans_apply]
  constructor <;>
  intro h <;>
  constructor <;>
  intro a ha
  constructor <;> intro h'
  ¬∑ simp only [comap_apply, RingHom.coe_coe, AlgEquiv.trans_apply]
    rw [‚Üê hf _, ‚Üê hf _]
    apply (h.1 (f.symm a) (f.symm ha)).1
    rw [hf' _, hf' _]
    exact h'
  ¬∑ rw [‚Üê hf' _, ‚Üê hf' _]
    apply (h.1 (f.symm a) (f.symm ha)).2
    simp only [comap_apply, RingHom.coe_coe]
    rw [hf _, hf _]
    exact h'
   -- need theorem/def of lift of f to integer is isom
  ¬∑ nth_rw 2 [‚Üê AlgEquiv.symm_apply_apply f.symm a]
    simp only [AlgEquiv.symm_symm]
    rw [‚Üê _root_.map_sub f (s (f.symm a)) (f.symm a), ‚Üê hf _]
    apply h.2
    apply (mem_integer_iff _ _).2
    rw [hf' _]
    exact ha
  ¬∑ constructor <;> intro hs'
    ¬∑ simp only [comap_apply, RingHom.coe_coe]
      rw [hf _, hf _, ‚Üê AlgEquiv.symm_apply_apply f a, ‚Üê AlgEquiv.symm_apply_apply f ha]
      apply (h.1 (f a) (f ha)).1
      rw [‚Üê hf _, ‚Üê hf _]
      exact hs'
    ¬∑ simp only [comap_apply, RingHom.coe_coe, hf _, hf _] at hs'
      rw [‚Üê AlgEquiv.symm_apply_apply f a, ‚Üê AlgEquiv.symm_apply_apply f ha] at hs'
      rw [hf _, hf _]
      apply (h.1 (f a) (f ha)).2 hs'
  ¬∑ rw [hf _, _root_.map_sub, ‚Üê AlgEquiv.symm_apply_apply f a]
    nth_rw 2 [AlgEquiv.symm_apply_apply]
    apply h.2
    apply (mem_integer_iff _ _).2
    rw [‚Üê hf _]
    exact ha

end autCongr

section WithBot
-- this should be put into a suitable place, Also add `WithOne`? `WithTop`, `WithBot`, `WithOne`, `Multiplicative`, `Additive`
open Classical
-- there is no `ConditionallyCompleteLinearOrderTop` in mathlib ...
-- # The definition of `WithTop.instInfSet` have to be changed Ôºàdone in latest versionÔºâ
#check WithBot.linearOrder
noncomputable instance {Œ±} [ConditionallyCompleteLinearOrder Œ±] : ConditionallyCompleteLinearOrderBot (WithBot Œ±) where
  toConditionallyCompleteLattice := WithBot.conditionallyCompleteLattice
  le_total := WithBot.linearOrder.le_total
  decidableLE := WithBot.decidableLE
  decidableEq := WithBot.decidableEq
  decidableLT := WithBot.decidableLT
  csSup_of_not_bddAbove s h := by
    rw [WithBot.sSup_empty]
    simp only [sSup, sInf, Set.subset_singleton_iff]
    by_cases hs : ‚àÄ y ‚àà s, y = (‚ä§ : WithTop Œ±·µí·µà)
    ¬∑ rw [if_pos (Or.inl hs)]; rfl
    ¬∑ rw [show (‚ä§ : WithTop Œ±·µí·µà) = (‚ä• : WithBot Œ±) by rfl, ite_eq_left_iff]
      intro h1
      push_neg at h1
      exfalso
      exact h h1.2
  csInf_of_not_bddBelow s h := by
    exfalso
    exact h (OrderBot.bddBelow s)
  bot_le := WithBot.orderBot.bot_le
  csSup_empty := by simp only [WithBot.sSup_empty]

noncomputable instance {Œ±} [ConditionallyCompleteLinearOrder Œ±] : ConditionallyCompleteLinearOrderBot (WithZero Œ±) := inferInstanceAs (ConditionallyCompleteLinearOrderBot (WithBot Œ±))

instance {Œ±} [Add Œ±] [ConditionallyCompleteLinearOrder Œ±] : ConditionallyCompleteLinearOrder (Multiplicative Œ±) := inferInstanceAs (ConditionallyCompleteLinearOrder Œ±)

-- noncomputable instance : ConditionallyCompleteLinearOrderBot ‚Ñ§‚Çò‚ÇÄ := inferInstanceAs (ConditionallyCompleteLinearOrderBot (WithZero ‚Ñ§))

end WithBot

section lowerIndex

variable (R S : Type*) [CommRing R] [Ring S] [vS : Valued S ‚Ñ§‚Çò‚ÇÄ] [Algebra R S]


open Classical
-- 0 if lower than 0
-- we define the lower index of ramification groups of ring extension S/R i_[S/R] : Gal(S/R) ‚Üí ‚Ñï‚àû (‚Ñï‚àû is somehow conflict with ‚Ñ§‚Çò‚ÇÄ, it causes some extra coercion), i_[S/R] s = sup_{x} v (s (x) - x)
noncomputable def AlgEquiv.lowerIndex (s : S ‚âÉ‚Çê[R] S) : ‚Ñï‚àû :=
  if h : ‚®Ü x : vS.v.integer, vS.v (s x - x) = 0 then ‚ä§
  else (- Multiplicative.toAdd (WithZero.unzero h)).toNat

scoped [Valued] notation:max " i_[" S:max "/" R:max "]" => AlgEquiv.lowerIndex R S


-- translate the type of lowerIndex from ‚Ñï‚àû to ‚Ñö
noncomputable def AlgEquiv.truncatedLowerIndex (u : ‚Ñö) (s : (S ‚âÉ‚Çê[R] S)) : ‚Ñö :=
  if h : i_[S/R] s = ‚ä§ then u
  else min u ((i_[S/R] s).untop h)

scoped [Valued] notation:max " i_[" L:max "/" K:max "]‚Çú" => AlgEquiv.truncatedLowerIndex K L

section lowerIndex_inequality

variable {R S}

/-- One of `val_map_sub_le_one` and `sub_self_mem_integer` should be thrown away.-/
theorem sub_self_mem_integer {s : S ‚âÉ‚Çê[R] S} (hs' : s ‚àà decompositionGroup R S)
  (x : vS.v.integer) :
    s x - x ‚àà vS.v.integer := by
  apply Subring.sub_mem
  ¬∑ rw [mem_integer_iff, val_map_le_one_iff hs']; exact x.2
  ¬∑ exact x.2

/-- One of `val_map_sub_le_one` and `sub_self_mem_integer` should be thrown away.-/
theorem val_map_sub_le_one {s : S ‚âÉ‚Çê[R] S} (hs' : s ‚àà decompositionGroup R S)
  (x : vS.v.integer) :
    v (s x - x) ‚â§ 1 := sub_self_mem_integer hs' x

--if sup_{x ‚àà S| v (x) ‚â§ 1} v (s (x) - x) ‚â† ‚àû, sup_{x ‚àà S| v (x) ‚â§ 1} v (s (x) - x) > 0
--is trivil in math, but is important in Lean and our project.
theorem toAdd_iSup_val_map_sub_le_zero_of_ne_zero {s : S ‚âÉ‚Çê[R] S} (hs' : s ‚àà decompositionGroup R S)
  (h : ‚®Ü x : vS.v.integer, vS.v (s x - x) ‚â† 0) :
    Multiplicative.toAdd (WithZero.unzero h) ‚â§ 0 := by
  change (WithZero.unzero h) ‚â§ 1
  suffices ‚®Ü x : vS.v.integer, vS.v (s x - x) ‚â§ 1 from by
    rw [‚Üê WithZero.coe_le_coe, WithZero.coe_unzero h]
    exact this
  apply ciSup_le <| val_map_sub_le_one hs'

section adjoin_singleton

variable {K L : Type*} [Field K] [Field L]
[vK : Valued K ‚Ñ§‚Çò‚ÇÄ] [vL : Valued L ‚Ñ§‚Çò‚ÇÄ] [Algebra K L] [IsValExtension K L]

/-- Should be strenthened to ` > 0`-/--??-/
--suppose the generator of ùí™[L] as a ùí™[K]-algebra exists.
theorem decomp_val_map_generator_sub_ne_zero {gen : ùí™[L]} (hgen : Algebra.adjoin ùí™[K] {gen} = ‚ä§)
  {s : L ‚âÉ‚Çê[K] L} (hs' : s ‚àà decompositionGroup K L) (hs : s ‚â† .refl) :
    vL.v (s gen - gen) ‚â† 0 := by
  by_contra h
  rw [zero_iff, sub_eq_zero] at h
  apply hs
  rw [elem_decompositionGroup_eq_iff_ValuationSubring' hs' (refl_mem_decompositionGroup K L)]
  apply Algebra.algHomClass_ext_generator hgen
  ext
  rw [DecompositionGroup.restrictValuationSubring_apply' hs',
    DecompositionGroup.restrictValuationSubring_apply' (refl_mem_decompositionGroup K L),
    h, AlgEquiv.coe_refl, id_eq]

open Polynomial in
theorem decomp_val_map_sub_le_generator {gen : ùí™[L]} (hgen : Algebra.adjoin ùí™[K] {gen} = ‚ä§) {s : L ‚âÉ‚Çê[K] L} (hs' : s ‚àà decompositionGroup K L) (x : ùí™[L]) : v (s x - x) ‚â§ v (s gen - gen) := by sorry
  -- by_cases hs : s = .refl
  -- ¬∑ subst hs
  --   simp only [AlgEquiv.coe_refl, id_eq, sub_self, _root_.map_zero, le_refl]
  -- rcases Algebra.exists_eq_aeval_generator hgen x with ‚ü®f, hf‚ü©
  -- subst hf
  -- rcases taylor_order_zero_apply_aeval f gen ((DecompositionGroup.restrictValuationSubring' hs') gen - gen) with ‚ü®b, hb‚ü©
  -- rw [add_sub_cancel, add_comm, ‚Üê sub_eq_iff_eq_add, aeval_algHom_apply, Subtype.ext_iff] at hb
  -- simp only [AddSubgroupClass.coe_sub, DecompositionGroup.restrictValuationSubring_apply' hs', Submonoid.coe_mul, Subsemiring.coe_toSubmonoid, Subring.coe_toSubsemiring] at hb
  -- rw [hb, Valuation.map_mul]
  -- nth_rw 2 [‚Üê mul_one (v (s gen - gen))]
  -- rw [mul_le_mul_left‚ÇÄ]
  -- ¬∑ exact b.2
  -- ¬∑ apply decomp_val_map_generator_sub_ne_zero hgen hs' hs

--sup_{x ‚àà S | v x ‚â§ 1} v (s (x) - x) = v (s gen - gen)
theorem decomp_iSup_val_map_sub_eq_generator {gen : ùí™[L]} (hgen : Algebra.adjoin ùí™[K] {gen} = ‚ä§) {s : L ‚âÉ‚Çê[K] L} (hs' : s ‚àà decompositionGroup K L) :
  ‚®Ü x : vL.v.integer, v (s x - x) = v (s gen - gen) := by
  apply le_antisymm
  ¬∑ letI : Nonempty ùí™[L] := inferInstanceAs (Nonempty vL.v.integer)
    apply ciSup_le <| decomp_val_map_sub_le_generator hgen hs'
  ¬∑ apply le_ciSup (f := fun (x : ùí™[L]) ‚Ü¶ v (s x - x)) _ gen
    use v (s gen - gen)
    intro y hy
    simp only [Set.mem_range, Subtype.exists, exists_prop] at hy
    rcases hy with ‚ü®a, ha‚ü©
    rw [‚Üê ha.2, show s a - a = s (‚ü®a, ha.1‚ü© : ùí™[L]) - (‚ü®a, ha.1‚ü© : ùí™[L]) by rfl]
    apply decomp_val_map_sub_le_generator hgen hs'


end adjoin_singleton

end lowerIndex_inequality

end lowerIndex

section ScalarTower

variable {R : Type*} {R' S: Type*} {ŒìR ŒìS ŒìA ŒìB : outParam Type*} [CommRing R] [CommRing R'] [Ring S]
[vS : Valued S ‚Ñ§‚Çò‚ÇÄ]
[Algebra R S] [Algebra R R'] [Algebra R' S] [IsScalarTower R R' S]

@[simp]
theorem lowerIndex_refl : (i_[S/R] .refl) = ‚ä§ := by
  simp only [AlgEquiv.lowerIndex, AlgEquiv.coe_refl, id_eq, sub_self, _root_.map_zero, ciSup_const,
    ‚ÜìreduceDIte]

@[simp]
theorem truncatedLowerIndex_refl (u : ‚Ñö) : AlgEquiv.truncatedLowerIndex R S u .refl = u := by
  simp only [AlgEquiv.truncatedLowerIndex, lowerIndex_refl, ‚ÜìreduceDIte]

section lowerIndex_inequality

section K_not_field

variable {K K' L : Type*} {ŒìK ŒìK' : outParam Type*} [CommRing K] [Field K'] [Field L] [LinearOrderedCommGroupWithZero ŒìK]
[LinearOrderedCommGroupWithZero ŒìK'] [vL : Valued L ‚Ñ§‚Çò‚ÇÄ] [Algebra K L]
[Algebra K K'] [Algebra K' L] [IsScalarTower K K' L]

/-- Another version where `ùí™[L] is finite over ùí™[K]` -/
theorem lowerIndex_ne_one {s : L ‚âÉ‚Çê[K] L} (hs' : s ‚àà decompositionGroup K L) (hs : s ‚â† .refl) : i_[L/K] s ‚â† ‚ä§ := by
  intro heq
  simp only [AlgEquiv.lowerIndex, AddSubgroupClass.coe_sub,
    dite_eq_left_iff, ENat.coe_ne_top, imp_false, not_not] at heq
  have hL : ‚àÄ x : vL.v.integer, s x = x := by
    intro x
    apply le_of_eq at heq
    rw [‚Üê sub_eq_zero, ‚Üê Valuation.zero_iff vL.v, show (0 : ‚Ñ§‚Çò‚ÇÄ) = ‚ä• by rfl, eq_bot_iff]
    refine (ciSup_le_iff' ?_).mp heq x
    use 1
    intro a ha
    rcases ha with ‚ü®y, hy‚ü©
    rw [‚Üê hy]
    exact sub_self_mem_integer hs' _
  apply hs
  ext x
  rcases ValuationSubring.mem_or_inv_mem vL.v.valuationSubring x with h | h
  ¬∑ exact hL ‚ü®x, h‚ü©
  ¬∑ calc
    _ = (s x‚Åª¬π)‚Åª¬π := by simp only [inv_inv, map_inv‚ÇÄ]
    _ = _ := by rw [hL ‚ü®x‚Åª¬π, h‚ü©, inv_inv, AlgEquiv.coe_refl, id_eq]

@[simp]
theorem lowerIndex_eq_top_iff_eq_refl {s : L ‚âÉ‚Çê[K] L} (hs' : s ‚àà decompositionGroup K L) : i_[L/K] s = ‚ä§ ‚Üî s = .refl := by
  constructor <;> intro h
  ¬∑ contrapose! h
    apply lowerIndex_ne_one hs' h
  ¬∑ simp only [h, lowerIndex_refl]

theorem iSup_val_map_sub_eq_zero_iff_eq_refl {s : L ‚âÉ‚Çê[K] L} (hs' : s ‚àà decompositionGroup K L) :
  ‚®Ü x : vL.v.integer, vL.v (s x - x) = 0 ‚Üî s = .refl := by
  rw [‚Üê lowerIndex_eq_top_iff_eq_refl]
  simp only [AlgEquiv.toEquiv_eq_coe, EquivLike.coe_coe, AlgEquiv.lowerIndex, dite_eq_left_iff, ENat.coe_ne_top, imp_false, Decidable.not_not]
  exact hs'

end K_not_field

--K_is_Valued_field
section K_is_field

variable {K L : Type*} [Field K] [Field L]
[vK : Valued K ‚Ñ§‚Çò‚ÇÄ] [vL : Valued L ‚Ñ§‚Çò‚ÇÄ] [Algebra K L] [IsValExtension K L]

theorem mem_lowerRamificationGroup_of_le_neg_one {s : L ‚âÉ‚Çê[K] L} (hs : s ‚àà decompositionGroup K L) {u : ‚Ñ§} (hu : u ‚â§ -1) : s ‚àà G(L/K)_[u] := by
  unfold lowerRamificationGroup
  simp only [ofAdd_sub, ofAdd_neg, Subtype.forall, Subgroup.mem_mk, Set.mem_setOf_eq]
  constructor
  ¬∑ exact hs
  ¬∑ intro a ha
    apply le_trans (val_map_sub_le_one hs ‚ü®a, ha‚ü©)
    simp only [WithZero.one_le_coe, one_le_div', le_inv_iff_mul_le_one_left, ‚Üê ofAdd_add]
    refine Multiplicative.toAdd_le.mp ?_
    simp only [ofAdd_add, toAdd_mul, toAdd_ofAdd, toAdd_one]
    linarith [hu]

-- the type of `n` should be changed
-- instead, change when use this theorem
open Multiplicative in
theorem mem_lowerRamificationGroup_iff_of_generator
  {gen : ùí™[L]} (hgen : Algebra.adjoin ùí™[K] {gen} = ‚ä§)
  {s : L ‚âÉ‚Çê[K] L} (hs' : s ‚àà decompositionGroup K L) (n : ‚Ñï) :
    s ‚àà G(L/K)_[n] ‚Üî n + 1 ‚â§ i_[L/K] s := by
  simp only [lowerRamificationGroup, Subtype.forall, Subgroup.mem_mk,
    Set.mem_setOf_eq, AlgEquiv.lowerIndex]
  by_cases hrefl : s = .refl
  ¬∑ simp only [hrefl, AlgEquiv.coe_refl, id_eq, sub_self, _root_.map_zero, ofAdd_sub, ofAdd_neg,
    zero_le', implies_true, and_true, ciSup_const, ‚ÜìreduceDIte, le_top, iff_true]
    exact refl_mem_decompositionGroup K L
  ¬∑ have hne0 : ¬¨ ‚®Ü x : vL.v.integer, vL.v (s x - x) = 0 := by
      rw [iSup_val_map_sub_eq_zero_iff_eq_refl hs']; exact hrefl
    constructor
    ¬∑ intro ‚ü®_, hs‚ü©
      simp only [hne0, ‚ÜìreduceDIte, ge_iff_le]
      rw [show (n : ‚Ñï‚àû) + 1 = (n + 1 : ‚Ñï) by rfl, ‚Üê ENat.some_eq_coe, WithTop.coe_le_coe,
        Int.le_toNat (by simp only [Left.nonneg_neg_iff, toAdd_iSup_val_map_sub_le_zero_of_ne_zero hs']),
        le_neg]
      change _ ‚â§ toAdd (ofAdd (-(n + 1) : ‚Ñ§))
      rw [toAdd_le]
      /- The following part should be extracted.
      It is also used in `toAdd_iSup_val_map_sub_le_zero_of_ne_zero`. -/
      suffices ‚®Ü x : vL.v.integer, vL.v (s x - x) ‚â§ ofAdd (-(n + 1) : ‚Ñ§) from by
        rw [‚Üê WithZero.coe_le_coe, WithZero.coe_unzero hne0]
        exact this
      apply ciSup_le
      /- end -/
      intro x
      rw [neg_add']
      exact hs x.1 x.2
    ¬∑ intro h
      simp only [hs', true_and]
      simp only [hne0, ‚ÜìreduceDIte] at h
      rw [show (n : ‚Ñï‚àû) + 1 = (n + 1 : ‚Ñï) by rfl, ‚Üê ENat.some_eq_coe, WithTop.coe_le_coe,
        Int.le_toNat (by simp only [Left.nonneg_neg_iff, toAdd_iSup_val_map_sub_le_zero_of_ne_zero hs']),
        le_neg] at h
      change _ ‚â§ toAdd (ofAdd (-(n + 1) : ‚Ñ§)) at h
      rw [toAdd_le, ‚Üê WithZero.coe_le_coe, WithZero.coe_unzero hne0, neg_add'] at h
      intro x hx
      apply le_trans _ h
      apply le_ciSup (f := fun (x : vL.v.integer) ‚Ü¶ v (s x - x)) _ ‚ü®x, hx‚ü©
      use v (s gen - gen)
      intro a
      simp only [Set.mem_range, Subtype.exists, exists_prop, forall_exists_index, and_imp]
      intro x hx heq
      rw [‚Üê heq]
      apply decomp_val_map_sub_le_generator hgen hs' ‚ü®x, hx‚ü©


theorem mem_lowerRamificationGroup_of_le_truncatedLowerIndex_sub_one {s : L ‚âÉ‚Çê[K] L} (hs' : s ‚àà decompositionGroup K L) {gen : ùí™[L]} (hgen : Algebra.adjoin ùí™[K] {gen} = ‚ä§) {u r : ‚Ñö} (h : u ‚â§ i_[L/K]‚Çú r s - 1) : s ‚àà G(L/K)_[‚åàu‚åâ] := by
  unfold AlgEquiv.truncatedLowerIndex at h
  by_cases hu : u ‚â§ -1
  ¬∑ apply mem_lowerRamificationGroup_of_le_neg_one hs'
    exact Int.ceil_le.mpr hu
  ¬∑ push_neg at hu
    have hu' : ‚åàu‚åâ.toNat = ‚åàu‚åâ := by
      apply Int.toNat_of_nonneg
      apply Int.le_ceil_iff.2
      simp only [Int.cast_zero, zero_sub, hu]
    by_cases hs : i_[L/K] s = ‚ä§
    ¬∑ simp [hs] at h
      --maybe there is a better way
      have : (‚åàu‚åâ.toNat + 1) ‚â§ i_[L/K] s := by simp [hs]
      convert (mem_lowerRamificationGroup_iff_of_generator hgen hs' ‚åàu‚åâ.toNat).2 this
      rw [hu']
    ¬∑ simp [hs] at h
      have : (‚åàu‚åâ.toNat + 1) ‚â§ i_[L/K] s := by
        have h' : u + 1 ‚â§ min r ‚Üë(WithTop.untop (i_[L/K] s) hs) := by linarith [h]
        rw [‚Üê WithTop.coe_untop (i_[L/K] s) hs]
        convert (le_min_iff.1 h').right
        constructor <;> intro hle
        ¬∑ -- there might be a better way, it's too long :(
          have : u + 1 ‚â§ ‚åàu‚åâ.toNat + 1 := by
            simp only [add_le_add_iff_right]
            apply le_trans (Int.le_ceil u)
            rw [‚Üê Int.cast_natCast]
            simp only [Int.ofNat_toNat, Int.cast_max, Int.cast_zero, le_max_iff, le_refl, Int.cast_nonpos, true_or]
          simp only [‚Üê Nat.cast_one (R := ‚Ñï‚àû), ‚Üê Nat.cast_add] at hle
          apply WithTop.coe_le_coe.1 at hle
          apply le_trans this
          simp only [‚Üê Nat.cast_one (R := ‚Ñö), ‚Üê Nat.cast_add]
          norm_cast
        ¬∑ simp only [‚Üê Nat.cast_one (R := ‚Ñï‚àû), ‚Üê Nat.cast_add]
          apply WithTop.coe_le_coe.2
          simp only [Nat.cast_add, Nat.cast_id, Nat.cast_one]
          apply Int.ceil_le.2 at hle
          rw [Int.ceil_add_one, ‚Üê hu'] at hle
          exact Int.ofNat_le.mp hle
      convert (mem_lowerRamificationGroup_iff_of_generator hgen hs' ‚åàu‚åâ.toNat).2 this
      exact Eq.symm hu'

variable [IsDiscrete vK.v] [IsDiscrete vL.v] [IsValExtension K L] [CompleteSpace K] [FiniteDimensional K L]

theorem le_truncatedLowerIndex_sub_one_iff_mem_lowerRamificationGroup (s : L ‚âÉ‚Çê[K] L) (u : ‚Ñö) (r : ‚Ñö) (h : u + 1 ‚â§ r) {gen : ùí™[L]} (hgen : Algebra.adjoin ùí™[K] {gen} = ‚ä§) : u ‚â§ i_[L/K]‚Çú r s - 1 ‚Üî s ‚àà G(L/K)_[‚åàu‚åâ] := by
  by_cases hu : u ‚â§ -1
  ¬∑ constructor <;> intro hu'
    ¬∑ apply mem_lowerRamificationGroup_of_le_neg_one
      rw [decompositionGroup_eq_top]
      apply Subgroup.mem_top
      apply Int.ceil_le.2
      simp only [Int.reduceNeg, Int.cast_neg, Int.cast_one]
      apply hu
    ¬∑ unfold AlgEquiv.truncatedLowerIndex
      by_cases hc : i_[L/K] s = ‚ä§
      ¬∑ simp only [hc, ‚ÜìreduceDIte]
        linarith
      ¬∑ simp only [hc, ‚ÜìreduceDIte]
        by_cases hr : r ‚â§ (WithTop.untop (i_[L/K] s) hc)
        ¬∑ rw [min_eq_left hr]
          linarith
        ¬∑ push_neg at hr
          rw [min_eq_right (le_of_lt hr)]
          have : 0 ‚â§ ((WithTop.untop (i_[L/K] s) hc : ‚Ñï) : ‚Ñö) := Nat.cast_nonneg' (WithTop.untop ( i_[L/K] s) hc)
          linarith
  ¬∑ push_neg at hu
    have hu' : ‚åàu‚åâ.toNat = ‚åàu‚åâ := by
      apply Int.toNat_of_nonneg
      apply Int.le_ceil_iff.2
      simp only [Int.cast_zero, zero_sub, hu]
    constructor
    ¬∑ apply mem_lowerRamificationGroup_of_le_truncatedLowerIndex_sub_one _ hgen
      rw [decompositionGroup_eq_top]
      apply Subgroup.mem_top
    ¬∑ intro hs
      have h1 : (‚åàu‚åâ.toNat + 1) ‚â§ i_[L/K] s := by
        apply (mem_lowerRamificationGroup_iff_of_generator hgen ?_ ‚åàu‚åâ.toNat).1
        --the type of N and Z make some truble
        rw [hu']
        exact hs
        rw [decompositionGroup_eq_top]
        apply Subgroup.mem_top
      unfold AlgEquiv.truncatedLowerIndex
      by_cases hc : i_[L/K] s = ‚ä§
      ¬∑ simp [hc]
        linarith [h]
      ¬∑ simp [hc]
        have hle : u + 1 ‚â§ min r ‚Üë(WithTop.untop ( i_[L/K] s) (of_eq_false (eq_false hc) : ¬¨ i_[L/K] s = ‚ä§)) := by
          apply le_min_iff.2
          constructor
          ¬∑ exact h
          ¬∑ have hle' : u + 1 ‚â§ ‚åàu‚åâ.toNat + 1 := by
              simp only [add_le_add_iff_right]
              apply le_trans (Int.le_ceil u)
              rw [‚Üê Int.cast_natCast]
              simp only [Int.ofNat_toNat, Int.cast_max, Int.cast_zero, le_max_iff, le_refl, Int.cast_nonpos, true_or]
            apply le_trans hle'
            rw [‚Üê Nat.cast_one, ‚Üê Nat.cast_add]
            apply Nat.mono_cast
            exact (WithTop.le_untop_iff (of_eq_false (eq_false hc))).mpr h1
        linarith [hle]



end K_is_field

end lowerIndex_inequality
--independent of the existence of the generator of ring ext.
@[simp]
theorem lowerIndex_restrictScalars (s : S ‚âÉ‚Çê[R'] S) : i_[S/R] (s.restrictScalars R) =  i_[S/R'] s := rfl

@[simp]
theorem truncatedLowerIndex_restrictScalars (u : ‚Ñö) (s : S ‚âÉ‚Çê[R'] S) : i_[S/R]‚Çú u (s.restrictScalars R) = i_[S/R']‚Çú u s := rfl

@[simp]
theorem lowerRamificationGroup_restrictScalars (u : ‚Ñ§) : G(S/R)_[u].comap (AlgEquiv.restrictScalarsHom R) = G(S/R')_[u] := rfl

end ScalarTower

section ExhausiveSeperated

section lower_eq_decomp

variable {R : Type*} {R' S: Type*} {ŒìR ŒìS ŒìA ŒìB : outParam Type*} [CommRing R] [CommRing R'] [Ring S]
[vS : Valued S ‚Ñ§‚Çò‚ÇÄ] [Algebra R S] [Algebra R R'] [Algebra R' S] [IsScalarTower R R' S]

theorem lowerRamificationGroup_eq_decompositionGroup {u : ‚Ñ§} (h : u ‚â§ -1) :
G(S/R)_[u] = decompositionGroup R S := by
  ext s
  simp only [lowerRamificationGroup, ofAdd_sub, ofAdd_neg, Subtype.forall, Subgroup.mem_mk,
    Set.mem_setOf_eq, and_iff_left_iff_imp]
  intro hs a ha
  calc
    _ ‚â§ max (v (s a)) (v a) := Valuation.map_sub _ _ _
    _ ‚â§ 1 := max_le ((val_map_le_one_iff hs a).mpr ha) ha
    _ ‚â§ _ := by
      show (.coe (0 : ‚Ñ§) : ‚Ñ§‚Çò‚ÇÄ) ‚â§ .coe ((- u - 1) : ‚Ñ§)
      norm_cast
      show (0 : ‚Ñ§) ‚â§ - u - 1
      linarith

end lower_eq_decomp

section eq_top

variable {K L : Type*} [Field K] [Field L] [vK : Valued K ‚Ñ§‚Çò‚ÇÄ] [IsDiscrete vK.v] [vL : Valued L ‚Ñ§‚Çò‚ÇÄ] [Algebra K L] [FiniteDimensional K L]

theorem lowerRamificationGroup_eq_top [IsValExtension K L] [CompleteSpace K] {u : ‚Ñ§} (h : u ‚â§ -1) : G(L/K)_[u] = ‚ä§ := by
  rw [lowerRamificationGroup_eq_decompositionGroup h, decompositionGroup_eq_top]

end eq_top

section eq_bot

open ExtDVR IsValExtension Polynomial

-- `IsDiscrete vK.v` may be weakened to `Nontrivial vK.v`.
variable (K L : Type*) [Field K] [Field L] [vK : Valued K ‚Ñ§‚Çò‚ÇÄ] [IsDiscrete vK.v] [vL : Valued L ‚Ñ§‚Çò‚ÇÄ] [IsDiscrete vL.v] [Algebra K L] [IsValExtension K L] [FiniteDimensional K L] [Algebra.IsSeparable K L]

variable {K L}
variable [CompleteSpace K]

theorem AlgEquiv.mem_decompositionGroup [CompleteSpace K] (s : L ‚âÉ‚Çê[K] L) : s ‚àà decompositionGroup K L := by
  rw [decompositionGroup_eq_top]
  exact Subgroup.mem_top s

--it's already in ValExtension
instance : IsLocalHom (algebraMap ùí™[K] ùí™[L]) where
    map_nonunit r hr := by
      by_cases h : r = 0
      ¬∑ simp [h] at hr
      ¬∑ apply Valuation.Integers.isUnit_of_one (v := vK.v)
        ¬∑ exact Valuation.integer.integers (v := vK.v)
        ¬∑ simpa only [Algebra.algebraMap_ofSubring_apply, isUnit_iff_ne_zero, ne_eq,
          ZeroMemClass.coe_eq_zero]
        ¬∑ apply Valuation.Integers.one_of_isUnit (Valuation.integer.integers (v := vL.v)) at hr
          change v (((algebraMap ‚Ü•ùí™[K] ‚Ü•ùí™[L]) r) : L) = 1 at hr
          norm_cast at hr
          simp only [IsValExtension.val_map_eq_one_iff] at hr
          exact hr

instance : Module.Finite ùí™[K] ùí™[L] := Module.IsNoetherian.finite ùí™[K] ùí™[L]

set_option synthInstance.maxHeartbeats 1000000

theorem AlgEquiv.Simple_Extension_of_CDVR [CompleteSpace K] [Algebra.IsSeparable (LocalRing.ResidueField ùí™[K]) (LocalRing.ResidueField ùí™[L])] : ‚àÉ gen : ùí™[L], Algebra.adjoin ùí™[K] {gen} = ‚ä§ := ExtDVR.exists_primitive (A := ùí™[K]) (B := ùí™[L]) (integerAlgebra_injective K L)


--can delete the assumption of generator.
/-- Should be strenthened to ` > 0`-/
theorem AlgEquiv.val_map_generator_sub_ne_zero {gen : ùí™[L]} (hgen : Algebra.adjoin ùí™[K] {gen} = ‚ä§) {s : L ‚âÉ‚Çê[K] L} (hs : s ‚â† .refl) : vL.v (s gen - gen) ‚â† 0 := by
  by_contra h
  rw [zero_iff, sub_eq_zero] at h
  apply hs
  rw [AlgEquiv.eq_iff_ValuationSubring]
  apply Algebra.algHomClass_ext_generator hgen
  ext; simp only [AlgEquiv.restrictValuationSubring_apply, h, AlgEquiv.coe_refl, id_eq]

/--  The orginal proof uses `PowerBasis.adjoin_gen_eq_top`.
Should be strenthened to ` > 0`-/
theorem AlgEquiv.val_map_powerBasis_sub_ne_zero (pb : PowerBasis ùí™[K] ùí™[L]) {s : L ‚âÉ‚Çê[K] L} (hs : s ‚â† .refl) :
  vL.v (s pb.gen - pb.gen) ‚â† 0 :=
  s.val_map_generator_sub_ne_zero (PowerBasis.adjoin_gen_eq_top pb) hs

open Polynomial in
theorem AlgEquiv.val_map_sub_le_generator {gen : ùí™[L]} (hgen : Algebra.adjoin ùí™[K] {gen} = ‚ä§) (s : L ‚âÉ‚Çê[K] L) (x : ùí™[L]) : v (s x - x) ‚â§ v (s gen - gen) := by
  sorry
  -- by_cases hs : s = .refl
  -- ¬∑ subst hs
  --   simp only [AlgEquiv.coe_refl, id_eq, sub_self, _root_.map_zero, le_refl]
  -- rcases Algebra.exists_eq_aeval_generator hgen x with ‚ü®f, hf‚ü©
  -- subst hf
  -- rcases taylor_order_zero_apply_aeval f gen ((AlgEquiv.restrictValuationSubring s) gen - gen) with ‚ü®b, hb‚ü©
  -- rw [add_sub_cancel, add_comm, ‚Üê sub_eq_iff_eq_add, aeval_algHom_apply, Subtype.ext_iff] at hb
  -- simp only [AddSubgroupClass.coe_sub, AlgEquiv.restrictValuationSubring_apply, Submonoid.coe_mul, Subsemiring.coe_toSubmonoid, Subring.coe_toSubsemiring] at hb
  -- rw [hb, Valuation.map_mul]
  -- nth_rw 2 [‚Üê mul_one (v (s gen - gen))]
  -- rw [mul_le_mul_left‚ÇÄ]
  -- ¬∑ exact b.2
  -- ¬∑ apply AlgEquiv.val_map_generator_sub_ne_zero hgen hs

open Polynomial in
/-- The orginal proof uses `PowerBasis.exists_eq_aeval`. -/
theorem AlgEquiv.val_map_sub_le_powerBasis (pb : PowerBasis ùí™[K] ùí™[L]) (s : L ‚âÉ‚Çê[K] L) (x : ùí™[L]) : vL.v (s x - x) ‚â§ vL.v (s pb.gen - pb.gen) := AlgEquiv.val_map_sub_le_generator (PowerBasis.adjoin_gen_eq_top pb) s x

theorem AlgEquiv.iSup_val_map_sub_eq_generator {gen : ùí™[L]} (hgen : Algebra.adjoin ùí™[K] {gen} = ‚ä§) (s : L ‚âÉ‚Çê[K] L) :
  ‚®Ü x : vL.v.integer, v (s x - x) = v (s gen - gen) := by
  apply le_antisymm
  ¬∑ letI : Nonempty ùí™[L] := inferInstanceAs (Nonempty vL.v.integer)
    apply ciSup_le <| AlgEquiv.val_map_sub_le_generator hgen s
  ¬∑ apply le_ciSup (f := fun (x : ùí™[L]) ‚Ü¶ v (s x - x)) _ gen
    use v (s gen - gen)
    intro y hy
    simp only [Set.mem_range, Subtype.exists, exists_prop] at hy
    rcases hy with ‚ü®a, ha‚ü©
    rw [‚Üê ha.2, show s a - a = s (‚ü®a, ha.1‚ü© : ùí™[L]) - (‚ü®a, ha.1‚ü© : ùí™[L]) by rfl]
    apply AlgEquiv.val_map_sub_le_generator hgen

/-- The original proof uses `AlgEquiv.val_map_sub_le_powerBasis`. -/
theorem AlgEquiv.iSup_val_map_sub_eq_powerBasis (pb : PowerBasis ùí™[K] ùí™[L]) (s : L ‚âÉ‚Çê[K] L) :
  ‚®Ü x : vL.v.integer, v (s x - x) = v (s pb.gen - pb.gen) :=
  AlgEquiv.iSup_val_map_sub_eq_generator (PowerBasis.adjoin_gen_eq_top pb) s

open Classical in
/-- Should I `open Classical`? -/
theorem lowerIndex_of_powerBasis (pb : PowerBasis ùí™[K] ùí™[L]) (s : L ‚âÉ‚Çê[K] L) :
  i_[L/K] s = if h : s = .refl then (‚ä§ : ‚Ñï‚àû)
    else (- Multiplicative.toAdd (WithZero.unzero (AlgEquiv.val_map_powerBasis_sub_ne_zero pb h))).toNat := by
  by_cases h : s = .refl
  ¬∑ simp only [h, lowerIndex_refl, ‚ÜìreduceDIte]
  ¬∑ unfold AlgEquiv.lowerIndex
    simp only [h, AlgEquiv.iSup_val_map_sub_eq_powerBasis pb, AlgEquiv.val_map_powerBasis_sub_ne_zero pb h, ‚ÜìreduceDIte]

@[simp]
theorem lowerIndex_ne_refl {s : L ‚âÉ‚Çê[K] L} (hs : s ‚â† .refl) : i_[L/K] s ‚â† ‚ä§ := by
  apply lowerIndex_ne_one
  rw [decompositionGroup_eq_top]
  apply Subgroup.mem_top s
  exact hs

variable (K L) in
theorem iSup_ne_refl_lowerIndex_ne_top [Nontrivial (L ‚âÉ‚Çê[K] L)] :
  ‚®Ü s : {s : (L ‚âÉ‚Çê[K] L) // s ‚â† .refl}, i_[L/K] s ‚â† ‚ä§ := by
  rw [‚Üê lt_top_iff_ne_top, iSup_lt_iff]
  let f : {s : (L ‚âÉ‚Çê[K] L) // s ‚â† .refl} ‚Üí ‚Ñï :=
    fun s ‚Ü¶ WithTop.untop _ (lowerIndex_ne_refl s.2)
  letI : Nonempty {s : (L ‚âÉ‚Çê[K] L) // s ‚â† .refl} := Exists.casesOn (exists_ne AlgEquiv.refl)
    fun s hs ‚Ü¶ Nonempty.intro ‚ü®s, hs‚ü©
  rcases Finite.exists_max f with ‚ü®a, ha‚ü©
  use f a
  constructor
  ¬∑ exact WithTop.coe_lt_top _
  ¬∑ intro s
    have : i_[L/K] s = f s := by
      rw [‚Üê ENat.some_eq_coe, WithTop.coe_untop]
    simp only [ne_eq, this, Nat.cast_le, ha]

-- if n > sup_{s ‚â† 1} i_G s then G_n = {1}.
theorem aux7 [Algebra.IsSeparable K L] [Algebra (LocalRing.ResidueField ùí™[K]) (LocalRing.ResidueField ùí™[L])] [Algebra.IsSeparable (LocalRing.ResidueField ùí™[K]) (LocalRing.ResidueField ùí™[L])]
  {n : ‚Ñï} (hu : n > ‚®Ü s : {s : (L ‚âÉ‚Çê[K] L) // s ‚â† .refl}, i_[L/K] s)
  {s : L ‚âÉ‚Çê[K] L} (hs : s ‚àà G(L/K)_[n]) : s = .refl := by
  apply (mem_lowerRamificationGroup_iff_of_generator (PowerBasis.adjoin_gen_eq_top (PowerBasisValExtension K L)) s.mem_decompositionGroup n).mp at hs
  by_contra! h
  rw [ENat.add_one_le_iff (by simp only [ne_eq, ENat.coe_ne_top, not_false_eq_true])] at hs
  have : i_[L/K] s < n := by
    apply lt_of_le_of_lt _ hu
    rw [show s = (‚ü®s, h‚ü© : {s // s ‚â† .refl}).1 by rfl]
    apply le_iSup (fun (x : {s // s ‚â† .refl}) => i_[L/K] x) (‚ü®s, h‚ü© : {s // s ‚â† .refl})
  apply lt_asymm hs this

-- this uses local fields and bichang's work, check if the condition is too strong..., It should be O_L is finitely generated over O_K
theorem exist_lowerRamificationGroup_eq_bot [CompleteSpace K] [Algebra.IsSeparable K L] [Algebra (LocalRing.ResidueField ùí™[K]) (LocalRing.ResidueField ùí™[L])]
  [Algebra.IsSeparable (LocalRing.ResidueField ùí™[K]) (LocalRing.ResidueField ùí™[L])] :
    ‚àÉ u : ‚Ñ§, G(L/K)_[u] = ‚ä• := by
  by_cases h : Nontrivial (L ‚âÉ‚Çê[K] L)
  ¬∑ use (WithTop.untop _ (iSup_ne_refl_lowerIndex_ne_top K L) : ‚Ñï) + 1
    rw [eq_bot_iff]
    intro s hs
    rw [Subgroup.mem_bot, AlgEquiv.aut_one, aux7 _ hs]
    rw [‚Üê ENat.some_eq_coe]
    simp only [WithTop.coe_add, WithTop.coe_untop, WithTop.coe_one, gt_iff_lt]
    nth_rw 1 [‚Üê add_zero (‚®Ü s : {s : (L ‚âÉ‚Çê[K] L) // s ‚â† .refl}, i_[L/K] s)]
    have : (0 : ‚Ñï‚àû) < 1 := by
      rw [‚Üê ENat.coe_one, ‚Üê ENat.some_eq_coe, WithTop.coe_pos]
      exact zero_lt_one
    convert WithTop.add_lt_add_left (iSup_ne_refl_lowerIndex_ne_top K L) this
  ¬∑ use 0
    rw [eq_bot_iff]
    intro s _
    rw [Subgroup.mem_bot, AlgEquiv.aut_one]
    letI : Subsingleton (L ‚âÉ‚Çê[K] L) := not_nontrivial_iff_subsingleton.mp h
    apply Subsingleton.allEq

variable [LocalField K] [LocalField L] [Algebra.IsSeparable K L]

end eq_bot

end ExhausiveSeperated

section sum_lowerIndex
#check lowerIndex_of_powerBasis
#check PowerBasisValExtension


open LocalField

variable {K M L : Type*} [Field K] [Field M] [Field L]
[Algebra K L] [Algebra K M] [Algebra M L]
[Normal K L]
[IsScalarTower K M L]
[FiniteDimensional K L] [FiniteDimensional K M] [FiniteDimensional M L]
[Normal K M]
[vK : Valued K ‚Ñ§‚Çò‚ÇÄ] [IsDiscrete vK.v]
[vM : Valued M ‚Ñ§‚Çò‚ÇÄ] [IsDiscrete vM.v]
[vL : Valued L ‚Ñ§‚Çò‚ÇÄ] [IsDiscrete vL.v]
[IsValExtension K L] [IsValExtension M L] [IsValExtension K M]
[Algebra.IsSeparable K L] [Algebra.IsSeparable M L] [Algebra.IsSeparable K M]
[CompleteSpace K] [CompleteSpace M]

-- #synth FiniteDimensional M L

#check AlgEquiv.restrictNormalHom_surjective

variable (œÉ : M ‚âÉ‚Çê[K] M) (s : L ‚âÉ‚Çê[K] L)
#check s.restrictNormal M
#check (AlgEquiv.restrictNormalHom (K‚ÇÅ := L) M)‚Åª¬π' {œÉ}
#synth Finite ((AlgEquiv.restrictNormalHom (K‚ÇÅ := L) M)‚Åª¬π' {œÉ})
#check Finset.sum

#check LocalField

--#check aux2 K L
open AlgEquiv Classical

#check Eq.subst
theorem preimage_nerefl (hsig : œÉ ‚â† .refl) (s : L ‚âÉ‚Çê[K] L) (hs : s ‚àà ((restrictNormalHom M)‚Åª¬π' {œÉ})) : s ‚â† .refl := by
  by_contra hc
  have h : (restrictNormalHom M) (.refl (A‚ÇÅ := L)) = .refl (R := K) := (restrictNormalHom M).map_one
  simp only [Set.mem_preimage, Set.mem_singleton_iff, hc, h] at hs
  absurd hsig
  exact id (Eq.symm hs)

#check AlgEquiv.val_map_powerBasis_sub_ne_zero
theorem val_mappb_sub_self_toAdd_nonpos {s : L ‚âÉ‚Çê[K] L} (hs : s ‚â† .refl) (x : PowerBasis ùí™[K] ùí™[L]) : 0 ‚â§ -Multiplicative.toAdd (WithZero.unzero (val_map_powerBasis_sub_ne_zero x hs)) := by
  rw [‚Üê toAdd_one, ‚Üê toAdd_inv]
  apply Multiplicative.toAdd_le.2
  apply one_le_inv'.mpr
  rw [‚Üê WithZero.coe_le_coe]
  simp only [WithZero.coe_unzero, WithZero.coe_one]
  apply val_map_sub_le_one _ x.gen
  exact mem_decompositionGroup s

-- @[coe, match_pattern] def WithZero.some {Œ± : Type*} : Œ± ‚Üí WithTop Œ± :=
--   Option.some

-- def addHom {Œ± : Type*} [AddZeroClass Œ±] : Œ± ‚Üí+ WithZero Œ± where
--   toFun := WithTop.some
--   map_zero' := by
--     simp only [WithTop.coe_zero]
--     sorry
--   map_add' _ _ := rfl

#check Nat.cast_prod
#check WithTop.coe_sum
#check WithZero

def WithZero.some {Œ± : Type*} : Œ± ‚Üí WithZero Œ± :=
  Option.some

def WithZero.MulHom {Œ± : Type*} [Monoid Œ±] : Œ± ‚Üí* WithZero Œ± where
  toFun := WithZero.some
  map_one' := rfl
  map_mul' _ _ := rfl


theorem WithZero.coe_prod {Œ± Œ≤ : Type*} [CommMonoid Œ≤] {s : Finset Œ±} {f : Œ± ‚Üí Œ≤} : (‚Üë(‚àè x ‚àà s, f x) : WithZero Œ≤) =  (‚àè x ‚àà s, ‚Üë(f x : WithZero Œ≤)) := by
  simp only [WithZero.coe]
  apply map_prod WithZero.MulHom f s


open DiscreteValuationRing
#check Ideal.Quotient.algebraMap_quotient_pow_ramificationIdx
#check Ideal.span_singleton_pow
#check IsValExtension.coe_algebraMap_valuationSubring
theorem Valuation.prolongs_by_ramificationIndex {x : M} (hx1 : x ‚àà vM.v.valuationSubring) (hx2 : (‚ü®x, hx1‚ü© : vM.v.valuationSubring) ‚â† 0) : vM.v (x) ^ ramificationIdx M L = vL.v (algebraMap M L x) := by
  obtain ‚ü®œÄL, hpiL‚ü© := exists_Uniformizer_ofDiscrete vL.v
  obtain ‚ü®œÄM, hpiM‚ü© := exists_Uniformizer_ofDiscrete vM.v
  obtain ‚ü®n1, u1, hnu1‚ü© := pow_Uniformizer vM.v hx2 ‚ü®œÄM, hpiM‚ü©
  have ha1 : (algebraMap M L x) ‚àà vL.v.valuationSubring := (mem_valuationSubring_iff v ((algebraMap M L) x)).mpr ((IsValExtension.val_map_le_one_iff x).mpr hx1)
  have ha2 : (‚ü®algebraMap M L x, ha1‚ü© : vL.v.valuationSubring) ‚â† 0 := by
    apply Subtype.coe_ne_coe.1
    simp only [ZeroMemClass.coe_zero, ne_eq, map_eq_zero]
    simp only [‚Üê ne_eq]
    apply Subtype.coe_ne_coe.2 hx2
  obtain ‚ü®n2, u2, hnu2‚ü© := pow_Uniformizer vL.v ha2 ‚ü®œÄL, hpiL‚ü©
  have hirrL : Irreducible œÄL := by
    apply (irreducible_iff_uniformizer œÄL).2 (IsUniformizer_is_generator v hpiL)
  have hirrM : Irreducible œÄM := by
    apply (irreducible_iff_uniformizer œÄM).2 (IsUniformizer_is_generator v hpiM)
  simp only [SubmonoidClass.coe_pow] at hnu1 hnu2
  rw [hnu2, hnu1]
  simp only [_root_.map_mul, _root_.map_pow, val_valuationSubring_unit, mul_one]
  have hr : algebraMap M L œÄM ‚àà vL.v.valuationSubring := by
    apply (mem_valuationSubring_iff v ((algebraMap M L) œÄM)).mpr
    simp only [IsValExtension.val_map_le_one_iff]
    apply (mem_valuationSubring_iff vM.v œÄM).mp œÄM.2
  have hr' : (‚ü®algebraMap M L œÄM, hr‚ü© : vL.v.valuationSubring) ‚â† 0 := by
    apply Subtype.coe_ne_coe.1
    simp only [ZeroMemClass.coe_zero, ne_eq, map_eq_zero]
    exact Uniformizer_ne_zero vM.v hpiM
  obtain ‚ü®n, u, hnu‚ü© := pow_Uniformizer vL.v hr' ‚ü®œÄL,hpiL‚ü©
  have hrami : ramificationIdx M L = n := by
    unfold ramificationIdx LocalRing.ramificationIdx Ideal.ramificationIdx
    simp only [SubmonoidClass.coe_pow] at hnu
    have hinM : œÄM.1 ‚àà vM.v.integer := SetLike.coe_mem œÄM
    have hinL : œÄL.1 ‚àà vL.v.integer := SetLike.coe_mem œÄL
    have hinu : u.1.1 ‚àà vL.v.integer := SetLike.coe_mem u.1
    rw [_root_.Irreducible.maximalIdeal_eq (œñ := ‚ü®œÄM.1, hinM‚ü©), _root_.Irreducible.maximalIdeal_eq (œñ := ‚ü®œÄL.1, hinL‚ü©)]
    rw [‚Üê IsValExtension.coe_algebraMap_valuationSubring] at hnu
    have hnu' : ((algebraMap ‚Ü•ùí™[M] ‚Ü•ùí™[L]) œÄM) = (‚ü®œÄL.1, hinL‚ü© : vL.v.integer) ^ n * ‚ü®u.1, hinu‚ü©  := by
      apply SetLike.coe_eq_coe.mp
      simp only [IsValExtension.coe_algebraMap_integer, Subtype.coe_eta, Subring.coe_mul, SubmonoidClass.coe_pow]
      exact hnu
    have hspan : Ideal.span {œÄL ^ n * u.1} = Ideal.span {œÄL ^ n} := by
      apply Ideal.span_singleton_eq_span_singleton.2
      apply Associated.symm
      use u
    have heq : {n_1 | œÄL ^ n_1 ‚à£ œÄL ^ n} = {n_1 | n_1 ‚â§ n} := by
      ext t
      constructor <;> intro ht
      ¬∑ simp only [Set.mem_setOf_eq] at ht ‚ä¢
        have hnezero : œÄL ‚â† 0 := by
          apply_mod_cast Uniformizer_ne_zero vL.v hpiL
        have hneunit : ¬¨ IsUnit œÄL := by
          apply Uniformizer_not_isUnit vL.v hpiL
        apply (pow_dvd_pow_iff hnezero hneunit).1
        exact ht
      ¬∑ simp only [Set.mem_setOf_eq] at ht ‚ä¢
        apply pow_dvd_pow
        exact ht
    simp only [Subtype.coe_eta, Ideal.span_singleton_pow, Ideal.map_span, Set.image_singleton, hnu', hspan, Ideal.span_singleton_le_span_singleton, heq]
    apply le_antisymm
    ¬∑ exact csSup_le' fun ‚¶Éa‚¶Ñ a ‚Ü¶ a
    ¬∑ apply le_csSup
      use n
      unfold upperBounds
      simp only [Set.mem_setOf_eq, imp_self, implies_true]
      simp only [Set.mem_setOf_eq, le_refl]
    simp only [Subtype.coe_eta]
    exact hirrL
    simp only [Subtype.coe_eta]
    exact hirrM
  simp only [SubmonoidClass.coe_pow] at hnu
  rw [hrami]
  rw [hpiM, hpiL, ‚Üê pow_mul]
  apply congrArg
  apply_fun (algebraMap M L) at hnu1
  simp only [_root_.map_mul, _root_.map_pow, hnu, hnu2, mul_pow, ‚Üê pow_mul, mul_comm, mul_assoc] at hnu1
  rw [mul_comm (œÄL.1 ^ (n1 * n))] at hnu1
  symm
  let u3 : (vL.v.valuationSubring)À£ := {
    val := ‚ü®u.1.1 ^ n1 * (algebraMap M L) u1.1.1, by
      apply ValuationSubring.mul_mem
      ¬∑ apply pow_mem u.1.2
      ¬∑ refine (mem_valuationSubring_iff v ((algebraMap M L) ‚Üë‚Üëu1)).mpr ?_
        refine (IsValExtension.val_map_le_one_iff u1.1.1).mpr ?_
        apply (mem_valuationSubring_iff v u1.1.1).1 u1.1.2
      ‚ü©
    inv := ‚ü®(algebraMap M L) u1.1.1‚Åª¬π * u.1.1‚Åª¬π ^ n1, by
      apply ValuationSubring.mul_mem
      ¬∑ refine (mem_valuationSubring_iff v ((algebraMap M L) (‚Üë‚Üëu1)‚Åª¬π)).mpr ?_
        refine (IsValExtension.val_map_le_one_iff u1.1.1‚Åª¬π).mpr ?_
        apply (mem_valuationSubring_iff v u1.1.1‚Åª¬π).1
        have hu := u1.2.2
        have hinv : u1.1.1‚Åª¬π = (u1‚Åª¬π).1.1 := by
          rw [‚Üê Units.inv_eq_val_inv]
          apply DivisionMonoid.inv_eq_of_mul u1.1.1 ‚Üëu1.inv ?_
          exact (Submonoid.mk_eq_one v.valuationSubring.toSubmonoid).mp u1.val_inv
        rw [Units.inv_eq_val_inv] at hu
        rw [hinv]
        exact hu
      ¬∑ apply pow_mem
        have hu := u.2.2
        have hinv : u.1.1‚Åª¬π = (u‚Åª¬π).1.1 := by
          rw [‚Üê Units.inv_eq_val_inv]
          apply DivisionMonoid.inv_eq_of_mul u.1.1 ‚Üëu.inv ?_
          exact (Submonoid.mk_eq_one v.valuationSubring.toSubmonoid).mp u.val_inv
        rw [Units.inv_eq_val_inv] at hu
        rw [hinv]
        exact hu
      ‚ü©
    val_inv := by
      simp only [map_inv‚ÇÄ, inv_pow, MulMemClass.mk_mul_mk, map_inv, mul_assoc]
      simp only [‚Üê mul_assoc (algebraMap M L u1.1.1), isUnit_iff_ne_zero, ne_eq, map_eq_zero, ZeroMemClass.coe_eq_zero, Units.ne_zero, not_false_eq_true, IsUnit.mul_inv_cancel, one_mul]
      simp only [isUnit_iff_ne_zero, ne_eq, pow_eq_zero_iff', ZeroMemClass.coe_eq_zero,
        Units.ne_zero, false_and, not_false_eq_true, IsUnit.mul_inv_cancel]
      rfl
    inv_val := by
      simp only [map_inv‚ÇÄ, inv_pow, MulMemClass.mk_mul_mk, mul_assoc]
      simp only [‚Üê mul_assoc (u.1.1 ^ n1)‚Åª¬π, isUnit_iff_ne_zero, ne_eq, map_eq_zero, ZeroMemClass.coe_eq_zero, Units.ne_zero, not_false_eq_true, IsUnit.mul_inv_cancel, one_mul]
      simp only [isUnit_iff_ne_zero, ne_eq, pow_eq_zero_iff', ZeroMemClass.coe_eq_zero,
        Units.ne_zero, false_and, not_false_eq_true, IsUnit.inv_mul_cancel, one_mul, map_eq_zero]
      rfl
  }
  apply DiscreteValuationRing.unit_mul_pow_congr_pow (p := œÄL) (q := œÄL) hirrL hirrL u2 u3 _ _
  simp only [‚Üê MulMemClass.coe_mul, ‚Üê SubmonoidClass.coe_pow] at hnu1
  apply Subtype.coe_inj.1 hnu1


  -- apply Uniformizer_pow_eq_of_associated hpiL
  -- let u3 : (vL.v.valuationSubring)À£ := {
  --   val := ‚ü®(u.1.1 ^ n1) * (algebraMap M L u1.1.1) * u2.1.1‚Åª¬π, by
  --     apply ValuationSubring.mul_mem
  --     ¬∑ apply ValuationSubring.mul_mem
  --       ¬∑ exact pow_mem u.1.2 n1
  --       ¬∑ refine (mem_valuationSubring_iff v ((algebraMap M L) ‚Üë‚Üëu1)).mpr ?_
  --         refine (IsValExtension.val_map_le_one_iff u1.1.1).mpr ?_
  --         apply (mem_valuationSubring_iff v u1.1.1).1 u1.1.2
  --     ¬∑ sorry
  --     ‚ü©
  --   inv := ‚ü®u2.1.1 * (algebraMap M L u1.1.1‚Åª¬π) * (u.1.1‚Åª¬π) ^ n1, sorry‚ü©
  --   val_inv := by sorry
  --   inv_val := by sorry
  -- }
  -- use u3
  -- simp only [u3]
  -- rw [‚Üê mul_assoc]
  -- --this might be simpler
  -- have h : ‚ÜëœÄL ^ (n1 * n) * ((‚Üë‚Üëu ^ n1) * (algebraMap M L) ‚Üë‚Üëu1) = ‚ÜëœÄL ^ n2 * u2.1.1 := by
  --   rw [hnu1, pow_mul, mul_pow]
  --   ring
  -- simp only [h, isUnit_iff_ne_zero, ne_eq, ZeroMemClass.coe_eq_zero, Units.ne_zero,
  --   not_false_eq_true, IsUnit.mul_inv_cancel_right]


open Polynomial Algebra

-- #synth CommMonoid (Multiplicative ‚Ñ§)
-- #check Valuation
-- --i_G/H œÉ = (1 / e_L/K) * ‚àë_{s ‚Üí œÉ} i_G s
-- #check toAdd_prod
-- #check Valuation.map_mul
-- #check Valuation.map_eq_of_sub_lt

-- theorem exsit_preimage : ‚àÉ s : (L ‚âÉ‚Çê[K] L), (restrictNormalHom M) s = œÉ := by
--   apply AlgEquiv.restrictNormalHom_surjective

-- #check Subalgebra K L
-- #check AlgEquiv.restrictValuationSubring_apply
-- theorem adjoin_val_gen_eq_top (x : PowerBasis ùí™[K] ùí™[L]) : adjoin K {x.gen.1} = ‚ä§ := by
--   rw [adjoin_singleton_eq_range_aeval]
--   ext t
--   constructor <;> intro ht
--   ¬∑ trivial
--   ¬∑ cases' h : ValuationSubring.mem_or_inv_mem vL.v.valuationSubring t with h1 h1
--     ¬∑ obtain ‚ü®f, hf‚ü© := Algebra.exists_eq_aeval_generator (PowerBasis.adjoin_gen_eq_top x) (‚ü®t, h1‚ü© : vL.v.valuationSubring)
--       use Polynomial.ofSubring ùí™[K] f
--       simp only [AlgHom.toRingHom_eq_coe, RingHom.coe_coe]
--       simp only [‚Üê Subtype.coe_inj] at hf
--       rw [hf]
--       rw [aeval_eq_sum_range, aeval_eq_sum_range]
--       have heq : (Polynomial.ofSubring ùí™[K] f).natDegree = f.natDegree := by
--         simp only [Polynomial.ofSubring]
--         rw [Polynomial.natDegree_sum_eq_of_disjoint]
--         simp only [natDegree_monomial, ZeroMemClass.coe_eq_zero]
--         by_cases hc : f = 0
--         ¬∑ simp only [hc, support_zero, coeff_zero, ‚ÜìreduceIte, Finset.sup_empty, bot_eq_zero',natDegree_zero]
--         ¬∑ apply le_antisymm
--           ¬∑ apply Finset.sup_le
--             intro b hb
--             by_cases hc : f.coeff b = 0
--             ¬∑ simp only [hc, ‚ÜìreduceIte, zero_le]
--             ¬∑ simp only [hc, ‚ÜìreduceIte]
--               exact le_natDegree_of_mem_supp b hb
--           ¬∑ by_cases hc' : f.natDegree = 0
--             ¬∑ rw [hc']
--               simp only [zero_le]
--             ¬∑ apply (Finset.le_sup_iff _).2
--               use f.natDegree
--               constructor
--               ¬∑ apply natDegree_mem_support_of_nonzero hc
--               ¬∑ have hne : f.coeff f.natDegree ‚â† 0 := mem_support_iff.mp (natDegree_mem_support_of_nonzero hc)
--                 simp only [hne, ‚ÜìreduceIte, le_refl]
--               rw [bot_eq_zero']
--               by_contra hcon
--               simp only [not_lt, nonpos_iff_eq_zero] at hcon
--               absurd hc'
--               exact hcon
--         simp only [mem_support_iff, ne_eq, monomial_eq_zero_iff, ZeroMemClass.coe_eq_zero, and_self]
--         intro a ha b hb hab
--         simp only [Set.mem_setOf_eq] at ha hb
--         simp only [ne_eq, Function.comp_apply, natDegree_monomial, ZeroMemClass.coe_eq_zero, ha, ‚ÜìreduceIte, hb]
--         exact hab
--       simp only [heq, AddSubmonoidClass.coe_finset_sum]
--       apply Finset.sum_congr rfl
--       intro i hi
--       rw [coeff_ofSubring]
--       rfl
--     ¬∑ obtain ‚ü®f, hf‚ü© := Algebra.exists_eq_aeval_generator (PowerBasis.adjoin_gen_eq_top x) (‚ü®t‚Åª¬π, h1‚ü© : vL.v.valuationSubring)


--       sorry

#help tactic cases

theorem aux_1 (œÉ : M ‚âÉ‚Çê[K] M) (hœÉ : œÉ ‚â† .refl) (x : PowerBasis ùí™[K] ùí™[L]) (y : PowerBasis ùí™[K] ùí™[M]) [Algebra.IsSeparable (LocalRing.ResidueField ùí™[K]) (LocalRing.ResidueField ùí™[L])] [Algebra.IsSeparable (LocalRing.ResidueField ùí™[M]) (LocalRing.ResidueField ùí™[L])] : (algebraMap M L) (œÉ ‚Üëy.gen - ‚Üëy.gen) ‚à£ (‚àè x_1 ‚àà (‚áë(restrictNormalHom M (K‚ÇÅ := L)) ‚Åª¬π' {œÉ}).toFinset.attach, (x_1.1 x.gen - x.gen)) := by
  let a := (algebraMap M L) (œÉ ‚Üëy.gen - ‚Üëy.gen)
  let b := (‚àè x_1 ‚àà (‚áë(restrictNormalHom M (K‚ÇÅ := L)) ‚Åª¬π' {œÉ}).toFinset.attach, (x_1.1 x.gen - x.gen))
  have hin : ‚àÄ t : (L ‚âÉ‚Çê[M] L), t x.gen ‚àà ùí™[L] := by
    intro t
    rw [‚Üê DecompositionGroup.restrictValuationSubring_apply']
    refine SetLike.coe_mem ((DecompositionGroup.restrictValuationSubring' ?h) x.gen)
    exact mem_decompositionGroup t
  let f := ‚àè t ‚àà (‚ä§ : Set (L ‚âÉ‚Çê[M] L)).toFinset, (C (‚ü®t x.gen, hin t‚ü© : ùí™[L]) - X)
  obtain ‚ü®s, hs‚ü© := AlgEquiv.restrictNormalHom_surjective L œÉ
  have hin' : ‚àÄ t : ùí™[L], s t ‚àà ùí™[L] := by
    intro t
    rw [‚Üê DecompositionGroup.restrictValuationSubring_apply']
    refine SetLike.coe_mem ((DecompositionGroup.restrictValuationSubring' ?h) t)
    exact mem_decompositionGroup s
  let e : ùí™[L] ‚Üí+* ùí™[L] := {
      toFun := fun t => ‚ü®s t, hin' t‚ü©
      map_one' := by
        simp only [OneMemClass.coe_one, _root_.map_one]
        rfl
      map_mul' := by
        simp only [Subring.coe_mul, _root_.map_mul, MulMemClass.mk_mul_mk, implies_true]
      map_zero' := by
        simp only [ZeroMemClass.coe_zero, _root_.map_zero]
        rfl
      map_add' := by
        simp only [Subring.coe_add, _root_.map_add, AddMemClass.mk_add_mk, implies_true]
    }
  let sf := Polynomial.map e f
  let sf' := ‚àè t ‚àà (‚ä§ : Set (L ‚âÉ‚Çê[K] L)).toFinset, (X - C ((s * t) x.gen))
  have hcoeff : ‚àÄ i : ‚Ñï, coeff sf i = s (coeff f i).1 := by
    intro i
    rw [Polynomial.coeff_map]
    simp only [f, Polynomial.map_prod, e]
    simp only [Polynomial.map_sub, map_X, map_C, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk]
    -- rw [heq, Polynomial.map_prod]
    -- simp only [Polynomial.map_sub, map_X, map_C, RingHom.coe_coe]
  have : a ‚à£ b := by
    have ha : a = s (algebraMap M L y.gen) - (algebraMap M L y.gen) := by
      simp only [a]
      simp only [_root_.map_sub, sub_left_inj]
      rw [‚Üê hs]
      apply AlgEquiv.restrictNormal_commutes
    have hb : b = eval x.gen (sf - f) := by
      rw [eval_sub]
      have heq : eval x.gen f = 0 := by
        simp only [f, eval_prod, eval_sub, eval_X, eval_C]
        refine Finset.prod_eq_zero_iff.mpr ?_
        use .refl
        simp only [Set.top_eq_univ, Set.toFinset_univ, Finset.mem_univ, coe_refl, id_eq, sub_self, and_self]
      rw [heq, sub_zero]
      --this has be done
      simp only [b, sf, f]
      rw [Polynomial.map_prod]
      simp only [Polynomial.map_sub, map_X, map_C, mul_apply, Polynomial.eval_prod, eval_sub, eval_C, eval_X]
      sorry
    rw [ha, hb, ‚Üê eval_C (a := (s (algebraMap M L y.gen) - (algebraMap M L y.gen))) (x := x.gen.1), ‚Üê IsValExtension.coe_algebraMap_valuationSubring]
    use (eval (x.gen.1) (C (s ‚Üë((algebraMap ‚Ü•ùí™[M] ‚Ü•ùí™[L]) y.gen) - ‚Üë((algebraMap ‚Ü•ùí™[M] ‚Ü•ùí™[L]) y.gen))))‚Åª¬π * (eval x.gen (sf - f)).1
    rw [‚Üê mul_assoc]
    -- apply Polynomial.eval_dvd
    -- apply (Polynomial.C_dvd_iff_dvd_coeff _ _).2
    -- intro i
    -- rw [coeff_sub, hcoeff i]
    rw [mul_inv_cancel‚ÇÄ, one_mul]
    simp only [IsValExtension.coe_algebraMap_integer, _root_.map_sub, eval_sub, eval_C, ne_eq]
    by_contra hc
    absurd hœÉ
    have hs' : (s.restrictNormal M) = œÉ := hs
    simp only [sub_eq_zero, ‚Üê AlgEquiv.restrictNormal_commutes, hs'] at hc
    apply NoZeroSMulDivisors.algebraMap_injective M L at hc
    rw [eq_iff_ValuationSubring]
    apply PowerBasis.algHom_ext' y
    rw [‚Üê Subtype.val_inj, AlgEquiv.restrictValuationSubring_apply, AlgEquiv.restrictValuationSubring_apply, coe_refl, id_eq]
    exact hc
    -- have : (s.restrictNormal M) y.gen.1 = y.gen.1 := by
    --   have : Function.Injective (algebraMap M L) := by exact NoZeroSMulDivisors.algebraMap_injective M L
    --   apply this
    --   exact hc
      -- by_contra hc
      -- absurd hœÉ
      -- rw [sub_eq_zero] at hc
      -- rw [eq_iff_ValuationSubring]
      -- apply PowerBasis.algHom_ext' y
      -- rw [‚Üê Subtype.val_inj, AlgEquiv.restrictValuationSubring_apply, AlgEquiv.restrictValuationSubring_apply, coe_refl, id_eq]
      -- exact hc
    -- have hdvd : (algebraMap M L y.gen) ‚à£ f.coeff i := by
    --   use (algebraMap M L y.gen)‚Åª¬π * (f.coeff i)
    --   simp only [‚Üê mul_assoc]
    --   have : (algebraMap M L) ‚Üëy.gen * ((algebraMap M L) ‚Üëy.gen)‚Åª¬π = 1 := by
    --     refine mul_inv_cancel‚ÇÄ ?_
    --     refine (map_ne_zero_iff (algebraMap M L) ?hf).mpr ?_
    --     exact NoZeroSMulDivisors.algebraMap_injective M L
    --     simp only [ne_eq, ZeroMemClass.coe_eq_zero]
    --     sorry
    --   rw [this, one_mul]
    -- obtain ‚ü®t, ht‚ü© := hdvd
    -- have ht' : s (f.coeff i) = s ((algebraMap M L) y.gen) * t := by
    --   rw [ht]
    --   sorry
    -- use t
    -- nth_rw 2 [ht]
    -- rw [ht', sub_mul]
  sorry

instance : IsScalarTower ùí™[K] ùí™[M] ùí™[L] where
  smul_assoc x y z := SetLike.coe_eq_coe.mp (IsScalarTower.smul_assoc x.1 y.1 z.1)

instance : NoZeroSMulDivisors ùí™[M] ùí™[L] :=  NoZeroSMulDivisors.iff_algebraMap_injective.mpr (IsValExtension.integerAlgebra_injective M L)

def i (s : L ‚âÉ‚Çê[K] L) (hs : (restrictNormalHom M) s = œÉ) (a : { x // x ‚àà ((restrictNormalHom (K‚ÇÅ := L) M) ‚Åª¬π' {œÉ}).toFinset }) (ha : a ‚àà (‚áë(restrictNormalHom M) ‚Åª¬π' {œÉ}).toFinset.attach) : L ‚âÉ‚Çê[M] L where
  toFun x := (s‚Åª¬π * a) x
  invFun x := (a.1‚Åª¬π * s) x
  left_inv := by
    simp only [mul_apply, Function.LeftInverse]
    intro x
    rw [‚Üê eq_symm_apply, ‚Üê eq_symm_apply]
    rfl
  right_inv := by
    simp only [mul_apply, Function.RightInverse, Function.LeftInverse]
    intro x
    rw [‚Üê eq_symm_apply, ‚Üê eq_symm_apply]
    rfl
  map_mul' x y := by
    simp only [mul_apply, _root_.map_mul]
  map_add' x y := by simp only [mul_apply, _root_.map_add]
  commutes' x := by
    rcases a with ‚ü®a, ha'‚ü©
    simp only [Set.mem_toFinset, Set.mem_preimage, Set.mem_singleton_iff] at ha'
    simp only [mul_apply]
    rw [‚Üê AlgEquiv.restrictNormal_commutes,  ‚Üê AlgEquiv.restrictNormal_commutes]
    have hs : s.restrictNormal M = œÉ := hs
    have ha' : a.restrictNormal M = œÉ := ha'
    have hinv : (s‚Åª¬π.restrictNormal M) = (s.restrictNormal M)‚Åª¬π := by
      apply (restrictNormalHom M).map_inv
    rw [hinv, hs, ha']
    have hx : œÉ‚Åª¬π (œÉ x) = x := by
      rw [‚Üê eq_symm_apply]
      rfl
    rw [hx]

theorem AlgEquiv.restrictNormalHom_restrictScalarsHom {x : (L ‚âÉ‚Çê[M] L)} : AlgEquiv.restrictNormalHom M (AlgEquiv.restrictScalarsHom K x) = 1 := by sorry

#check (restrictNormalHom M).map_inv
theorem aux10 (œÉ : M ‚âÉ‚Çê[K] M) (s : L ‚âÉ‚Çê[K] L) (hs : (restrictNormalHom M) s = œÉ) (x : PowerBasis ùí™[K] ùí™[L]) : ‚àè x_1 ‚àà (‚áë(restrictNormalHom M) ‚Åª¬π' {œÉ}).toFinset.attach, (x_1.1 x.gen.1 - x.gen.1) = ‚àè x_1 ‚àà (‚ä§ : Set (L ‚âÉ‚Çê[M] L)).toFinset, (s (x_1 ‚Üëx.gen) - ‚Üëx.gen) := by
  apply Finset.prod_bij (i œÉ s hs)
  ¬∑ intro a ha
    simp only [i, Set.top_eq_univ, Set.toFinset_univ, mul_apply, Finset.mem_univ]
  ¬∑ intro a1 ha1 a2 ha2 ha
    simp only [i, mul_apply, AlgEquiv.mk.injEq, Equiv.mk.injEq] at ha
    rcases ha with ‚ü®ha1, ha2‚ü©
    ext x
    apply AlgEquiv.injective s‚Åª¬π
    apply congr_fun ha1
  ¬∑ intro b hb
    let a' : { x // x ‚àà ((restrictNormalHom M (K‚ÇÅ := L)) ‚Åª¬π' {œÉ}).toFinset} := {
      val := s * ((restrictScalarsHom K) b)
      property := by
        simp only [Set.mem_toFinset, Set.mem_preimage, _root_.map_mul, Set.mem_singleton_iff, hs, AlgEquiv.restrictNormalHom_restrictScalarsHom, mul_one]
    }
    have ha : a' ‚àà (‚áë(restrictNormalHom M) ‚Åª¬π' {œÉ}).toFinset.attach := Finset.mem_attach (‚áë(restrictNormalHom M) ‚Åª¬π' {œÉ}).toFinset a'
    use a'
    use ha
    simp only [i]
    simp only [inv_mul_cancel_left, mul_inv_rev, inv_mul_cancel_right]
    rfl
  ¬∑ intro a ha
    simp only [i, mul_apply, AlgEquiv.coe_mk, Equiv.coe_fn_mk, sub_left_inj]
    rw [‚Üê eq_symm_apply, eq_symm_apply, ‚Üê symm_symm s, eq_symm_apply]
    rfl

theorem aux_12 (x : PowerBasis ùí™[K] ùí™[L]) : ‚àÄ t : (L ‚âÉ‚Çê[M] L), t x.gen ‚àà ùí™[L] := by
  intro t
  rw [mem_integer_iff, val_map_le_one_iff, ‚Üê mem_integer_iff]
  exact SetLike.coe_mem x.gen
  exact algEquiv_preserve_val_of_complete t


theorem aux_13 (x : PowerBasis ùí™[K] ùí™[L]) : ‚àÄ t : (L ‚âÉ‚Çê[M] L), ‚ü®t x.gen, aux_12 x t‚ü© ‚àà (minpoly (‚Ü•ùí™[M]) x.gen).aroots ùí™[L] := by
  intro t
  simp only [mem_roots', ne_eq, IsRoot.def, eval_map_algebraMap]
  constructor
  ¬∑ by_contra hc
    have h1 : minpoly ùí™[M] x.gen = 0 := by
      apply_fun Polynomial.map (algebraMap ‚Ü•ùí™[M] ‚Ü•ùí™[L])
      simp only [Polynomial.map_zero]
      exact hc
      apply Polynomial.map_injective
      exact IsValExtension.integerAlgebra_injective M L
    have h2 : minpoly ùí™[M] x.gen ‚â† 0 := by
      apply minpoly.ne_zero
      exact IsIntegral.isIntegral x.gen
    exact h2 h1
  ¬∑ have hmem : t ‚àà decompositionGroup M L := mem_decompositionGroup t
    conv =>
      enter [1, 1, 1, 1]
      rw [‚Üê DecompositionGroup.restrictValuationSubring_apply' hmem]
    rw [SetLike.eta, aeval_algHom_apply]
    have hzero : ((aeval x.gen) (minpoly (‚Ü•ùí™[M]) x.gen)) = 0 := minpoly.aeval (‚Ü•ùí™[M]) x.gen
    rw [hzero]
    exact map_zero (DecompositionGroup.restrictValuationSubring' hmem)


def i1 (x : PowerBasis ùí™[K] ùí™[L]) (a : L ‚âÉ‚Çê[M] L) (ha : a ‚àà Finset.univ) : { y // y ‚àà (minpoly (‚Ü•ùí™[M]) x.gen).aroots ùí™[L]} := ‚ü®‚ü®a x.gen, aux_12 x a‚ü©, aux_13 x a‚ü©


def i2 (x : PowerBasis ùí™[K] ùí™[L]) (a : ùí™[M]) (ha : a ‚àà (minpoly (‚Ü•ùí™[M]) x.gen).roots) : ùí™[L] := ‚ü®algebraMap ùí™[M] ùí™[L] a, SetLike.coe_mem ((algebraMap ‚Ü•ùí™[M] ‚Ü•ùí™[L]) a)‚ü©

theorem aux_14 (x :ùí™[L]) : (minpoly M x.1) = Polynomial.ofSubring ùí™[M] (minpoly ùí™[M] x) := by sorry

instance : Algebra.IsSeparable ùí™[M] ùí™[L] where
  isSeparable' := by
    intro x
    simp only [IsSeparable]

    sorry



#check minpoly.unique
#check Polynomial.monic_prod_of_monic
#check minpoly.algebraMap_eq
#check Polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq
#check PowerBasis.liftEquiv'
theorem aux_11 (x : PowerBasis ùí™[K] ùí™[L]) : Polynomial.map (algebraMap ùí™[M] ùí™[L]) (minpoly ùí™[M] x.gen) = ‚àè t ‚àà (‚ä§ : Set (L ‚âÉ‚Çê[M] L)).toFinset, (X - C (‚ü®t x.gen, aux_12 x t‚ü© : ùí™[L])) := by
  rw [‚Üê Polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq (p := minpoly ùí™[M] x.gen)]
  simp only [Polynomial.map_multiset_prod]
  simp only [Multiset.map_map, Function.comp_apply, Polynomial.map_sub, map_X, map_C]
  simp only [Set.top_eq_univ, Set.toFinset_univ]
  --rw [@Fintype.prod_equiv (S ‚Üí‚Çê[R] F) _ _ (PowerBasis.AlgHom.fintype pb) _ _ pb.liftEquiv'(fun œÉ => œÉ pb.gen) (fun x => x) ?_]
  have hprod : ‚àè x_1 : L ‚âÉ‚Çê[M] L, (X - C (‚ü®x_1 ‚Üëx.gen, aux_12 x x_1‚ü© : ùí™[L])) = ‚àè t : { y // y ‚àà (minpoly ùí™[M] x.gen).aroots ùí™[L]}, (X - C t.1) := by
    apply Finset.prod_bij (i1 x)
    ¬∑ intro a ha
      simp only [i1, Finset.mem_univ]
    ¬∑ intro a1 ha1 a2 ha2 ha
      simp only [i1, Subtype.mk.injEq] at ha
      rw [eq_iff_ValuationSubring]
      apply_fun restrictScalars ùí™[K]
      apply PowerBasis.algHom_ext' x
      rw [‚Üê AlgEquiv.restrictValuationSubring_apply, ‚Üê AlgEquiv.restrictValuationSubring_apply] at ha
      simp only [Subtype.val_inj] at ha
      simp only [restrictScalars_apply]
      exact ha
      exact restrictScalarsHom_injective ‚Ü•ùí™[K]
      -- apply PowerBasis.algHom_ext'
      -- rw [‚Üê Subtype.val_inj, AlgEquiv.restrictValuationSubring_apply, AlgEquiv.restrictValuationSubring_apply]
      -- exact ha
    ¬∑ intro b hb
      simp only [i1]
      let a : L ‚âÉ‚Çê[M] L := {
        toFun := by sorry
        invFun := sorry
        left_inv := sorry
        right_inv := sorry
        map_mul' := sorry
        map_add' := sorry
        commutes' := sorry
      }
      use a
      have ha : a ‚àà Finset.univ := Finset.mem_univ a
      use ha

      sorry
    ¬∑ intro a ha
      simp only [i1]
  rw [hprod, Finset.prod_mem_multiset _ _ (fun t => X - C t), Finset.prod_eq_multiset_prod, Multiset.toFinset_val, Multiset.dedup_eq_self.mpr, Polynomial.aroots]
  have hmap : Multiset.map (fun x ‚Ü¶ X - C ((algebraMap ‚Ü•ùí™[M] ‚Ü•ùí™[L]) x)) (minpoly (‚Ü•ùí™[M]) x.gen).roots = Multiset.map (fun x ‚Ü¶ X - C x) (Polynomial.map (algebraMap ‚Ü•ùí™[M] ‚Ü•ùí™[L]) (minpoly (‚Ü•ùí™[M]) x.gen)).roots := by
    refine Multiset.map_eq_map_of_bij_of_nodup (fun x ‚Ü¶ X - C ((algebraMap ‚Ü•ùí™[M] ‚Ü•ùí™[L]) x)) (fun x ‚Ü¶ X - C x) ?_ ?_ (i2 x) ?_ ?_ ?_ ?_
    ¬∑ refine nodup_roots ?refine_1.hsep
      apply Algebra.IsSeparable.isSeparable'
    ¬∑ apply nodup_roots
      apply Polynomial.Separable.map
      apply Algebra.IsSeparable.isSeparable'
    ¬∑ intro a ha
      simp only [i2]
      simp only [IsValExtension.coe_algebraMap_integer, mem_roots', ne_eq, IsRoot.def, eval_map_algebraMap]
      constructor
      ¬∑ by_contra hc
        have h1 : minpoly ùí™[M] x.gen = 0 := by
          apply_fun Polynomial.map (algebraMap ‚Ü•ùí™[M] ‚Ü•ùí™[L])
          simp only [Polynomial.map_zero]
          exact hc
          apply Polynomial.map_injective
          exact IsValExtension.integerAlgebra_injective M L
        have h2 : minpoly ùí™[M] x.gen ‚â† 0 := by
          apply minpoly.ne_zero
          exact IsIntegral.isIntegral x.gen
        exact h2 h1
      ¬∑ simp only [‚Üê IsValExtension.coe_algebraMap_valuationSubring, SetLike.eta]
        apply (Polynomial.aeval_algebraMap_eq_zero_iff _ _ _).2
        apply (Polynomial.mem_roots_iff_aeval_eq_zero _).1 ha
        apply minpoly.ne_zero
        exact IsIntegral.isIntegral x.gen
    ¬∑ intro a1 ha1 a2 ha2 ha
      simp only [i2, IsValExtension.coe_algebraMap_integer, Subtype.mk.injEq, algebraMap.coe_inj, SetLike.coe_eq_coe] at ha
      exact ha
    ¬∑ intro b hb
      simp only [i2]
      -- obtain ‚ü®algMapinv, halg‚ü© := Function.Injective.hasLeftInverse (NoZeroSMulDivisors.algebraMap_injective ùí™[M] ùí™[L])
      -- let a := algMapinv b
      -- use a
      -- have ha : a ‚àà (minpoly (‚Ü•ùí™[M]) x.gen).roots := by sorry
      -- use ha
      -- simp only [a]
      -- simp only [IsValExtension.coe_algebraMap_integer]
      sorry
    ¬∑ intro a ha
      simp only [i2]
  rw [hmap]
  ¬∑ simp only [aroots]
    apply nodup_roots
    apply Polynomial.Separable.map
    apply Algebra.IsSeparable.isSeparable'
  ¬∑ intro x
    rfl
  ¬∑ refine minpoly.monic ?hp.hx
    exact IsIntegral.isIntegral x.gen
  ¬∑
    sorry



theorem aux_2 (œÉ : M ‚âÉ‚Çê[K] M) (x : PowerBasis ùí™[K] ùí™[L]) (y : PowerBasis ùí™[K] ùí™[M]) [Algebra.IsSeparable (LocalRing.ResidueField ùí™[K]) (LocalRing.ResidueField ùí™[L])] [Algebra.IsSeparable (LocalRing.ResidueField ùí™[M]) (LocalRing.ResidueField ùí™[L])] : (‚àè x_1 ‚àà (‚áë(restrictNormalHom M (K‚ÇÅ := L)) ‚Åª¬π' {œÉ}).toFinset.attach, (x_1.1 x.gen - x.gen)) ‚à£ (algebraMap M L) (œÉ ‚Üëy.gen - ‚Üëy.gen):= by
  let a := (algebraMap M L) (œÉ ‚Üëy.gen - ‚Üëy.gen)
  let b := (‚àè x_1 ‚àà (‚áë(restrictNormalHom M (K‚ÇÅ := L)) ‚Åª¬π' {œÉ}).toFinset.attach, (x_1.1 x.gen - x.gen))
  have hin : ‚àÄ t : (L ‚âÉ‚Çê[M] L), t x.gen ‚àà ùí™[L] := by
    intro t
    rw [‚Üê DecompositionGroup.restrictValuationSubring_apply']
    refine SetLike.coe_mem ((DecompositionGroup.restrictValuationSubring' ?h) x.gen)
    exact mem_decompositionGroup t
  let f := ‚àè t ‚àà (‚ä§ : Set (L ‚âÉ‚Çê[M] L)).toFinset, (C (‚ü®t x.gen, hin t‚ü© : ùí™[L]) - X)
  obtain ‚ü®s, hs‚ü© := AlgEquiv.restrictNormalHom_surjective L œÉ
  have hin' : ‚àÄ t : ùí™[L], s t ‚àà ùí™[L] := by
    intro t
    rw [‚Üê DecompositionGroup.restrictValuationSubring_apply']
    refine SetLike.coe_mem ((DecompositionGroup.restrictValuationSubring' ?h) t)
    exact mem_decompositionGroup s
  let e : ùí™[L] ‚Üí+* ùí™[L] := {
      toFun := fun t => ‚ü®s t, hin' t‚ü©
      map_one' := by
        simp only [OneMemClass.coe_one, _root_.map_one]
        rfl
      map_mul' := by
        simp only [Subring.coe_mul, _root_.map_mul, MulMemClass.mk_mul_mk, implies_true]
      map_zero' := by
        simp only [ZeroMemClass.coe_zero, _root_.map_zero]
        rfl
      map_add' := by
        simp only [Subring.coe_add, _root_.map_add, AddMemClass.mk_add_mk, implies_true]
    }
  let sf := Polynomial.map e f
  let sf' := ‚àè t ‚àà (‚ä§ : Set (L ‚âÉ‚Çê[K] L)).toFinset, (X - C ((s * t) x.gen))
  have : b ‚à£ a := by
    have hy : ‚àÉ g : ùí™[K][X], eval x.gen (Polynomial.map (algebraMap ùí™[K] ùí™[L]) g) = algebraMap ùí™[M] ùí™[L] y.gen := by
      obtain ‚ü®g, hg‚ü© := Algebra.exists_eq_aeval_generator (PowerBasis.adjoin_gen_eq_top x) (algebraMap ùí™[M] ùí™[L] y.gen)
      use g
      rw [hg]
      simp only [eval_map_algebraMap]
    -- have hmin : f = Polynomial.map (algebraMap M L) (minpoly M x.gen.1) := by sorry
    obtain ‚ü®g, hg‚ü© := hy
    let g_sub_y := Polynomial.map (algebraMap ùí™[K] ùí™[M]) g - C y.gen
    have ha : - a = eval x.gen (Polynomial.map e  (Polynomial.map (algebraMap ùí™[M] ùí™[L]) g_sub_y)) := by
      simp only [a, g_sub_y]
      have hg' : (Polynomial.map e (Polynomial.map (algebraMap ùí™[M] ùí™[L]) (Polynomial.map (algebraMap ùí™[K] ùí™[M]) g))) = (Polynomial.map (algebraMap ùí™[K] ùí™[L]) g) := by
        rw [Polynomial.map_map (algebraMap ùí™[K] ùí™[M]), ‚Üê (IsScalarTower.algebraMap_eq ùí™[K] ùí™[M] ùí™[L])]
        ext n
        simp only [coeff_map, e, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk, IsValExtension.coe_algebraMap_valuationSubring, AlgEquiv.commutes]
      simp only [_root_.map_sub, Polynomial.map_sub, map_C, hg', eval_sub, eval_map_algebraMap, eval_C, ‚Üê eval_map_algebraMap, hg, neg_sub, AddSubgroupClass.coe_sub, IsValExtension.coe_algebraMap_integer,sub_right_inj, e, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk, IsValExtension.coe_algebraMap_integer, ‚Üê hs]
      apply AlgEquiv.restrictNormal_commutes
      -- simp only [a, g_sub_y]
      -- have hg' : (Polynomial.map e (Polynomial.map (algebraMap M L) (Polynomial.map (algebraMap K M) g))) = (Polynomial.map (algebraMap K L)  g) := by
      --   rw [Polynomial.map_map (algebraMap K M), ‚Üê (IsScalarTower.algebraMap_eq K M L)]
      --   ext n
      --   simp only [coeff_map, e]
      --   simp only [RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk, AlgEquiv.commutes]
      -- simp only [_root_.map_sub, Polynomial.map_sub, map_C, hg', eval_sub, eval_map_algebraMap, eval_C]
      -- rw [‚Üê eval_map_algebraMap, hg]
      -- simp only [neg_sub, sub_right_inj, e]
      -- simp only [RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk, ‚Üê hs]
      -- apply AlgEquiv.restrictNormal_commutes
    have hdvd : minpoly ùí™[M] x.gen ‚à£ g_sub_y := by
      apply minpoly.isIntegrallyClosed_dvd
      exact IsIntegral.isIntegral x.gen
      simp only [g_sub_y, ‚Üê eval_map_algebraMap, Polynomial.map_sub, Polynomial.map_map (algebraMap ùí™[K] ùí™[M]) (algebraMap ùí™[M] ùí™[L]) g, ‚Üê (IsScalarTower.algebraMap_eq ùí™[K] ùí™[M] ùí™[L]), eval_sub, hg, map_C, eval_C, sub_self]
      -- apply minpoly.dvd_iff.2
      -- simp only [g_sub_y]
      -- rw [‚Üê eval_map_algebraMap, Polynomial.map_sub, Polynomial.map_map (algebraMap K M) (algebraMap M L) g, ‚Üê (IsScalarTower.algebraMap_eq K M L), eval_sub, hg]
      -- simp only [map_C, eval_C, sub_self]
    obtain ‚ü®h, hh‚ü© := hdvd
    have hb : b = eval x.gen sf := by
      simp only [b, sf, f]
      rw [Polynomial.map_prod]
      simp only [Polynomial.map_sub, map_X, map_C, mul_apply, Polynomial.eval_prod, eval_sub, eval_C, eval_X]
      simp only [ SubmonoidClass.coe_finset_prod,AddSubgroupClass.coe_sub, e]
      simp only [RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk]
      apply Finset.prod_bij
      --apply Finset.prod_bij
      repeat sorry
    have hmin : f = Polynomial.map (algebraMap ùí™[M] ùí™[L]) (minpoly ùí™[M] x.gen) := by
      sorry
    rw [‚Üê dvd_neg, ha, hb]
    simp only [sf, hmin]
    use (eval x.gen (Polynomial.map e (Polynomial.map (algebraMap ùí™[M] ùí™[L]) h))).1
    simp only [‚Üê Subring.coe_mul, Subtype.coe_inj]
    simp only [‚Üê eval_mul, ‚Üê Polynomial.map_mul]
    exact congrArg (eval x.gen) (congrArg (Polynomial.map e) (congrArg (Polynomial.map (algebraMap ‚Ü•ùí™[M] ‚Ü•ùí™[L])) hh))

    -- apply eval_dvd
    -- simp only [map_dvd_map']

    -- rw [ha, hb]
    -- apply Polynomial.eval_dvd
    -- use Polynomial.map (algebraMap M L) h
    -- ext i
    -- simp only [coeff_map]

    -- have hmin : f = Polynomial.map (algebraMap M L) (minpoly M x.gen.1) := by sorry
    -- rw [‚Üê dvd_neg, ha, hb]
    -- simp only [sf, hmin]
    -- apply eval_dvd
    -- simp only [map_dvd_map']
    -- use h
  sorry


#check Polynomial.map
#check Polynomial.C_dvd_iff_dvd_coeff
#check Polynomial.eval_dvd
#check Polynomial.reverse
#check Polynomial.comp
theorem prop3
  (œÉ : M ‚âÉ‚Çê[K] M) (x : PowerBasis ùí™[K] ùí™[L]) (y : PowerBasis ùí™[K] ùí™[M]) [Algebra.IsSeparable (LocalRing.ResidueField ùí™[K]) (LocalRing.ResidueField ùí™[L])] [Algebra.IsSeparable (LocalRing.ResidueField ùí™[M]) (LocalRing.ResidueField ùí™[L])] :
    ‚àë s ‚àà ((restrictNormalHom M)‚Åª¬π' {œÉ}), i_[L/K] s
    = (ramificationIdx M L) * i_[M/K] œÉ := by
  by_cases hœÉ : œÉ = .refl
  ¬∑ sorry
  -- ¬∑ subst hœÉ
  --   rw [lowerIndex_refl, ENat.mul_top]
  --   ¬∑ have : (.refl : L ‚âÉ‚Çê[K] L) ‚àà (restrictNormalHom M)‚Åª¬π' {.refl} := by
  --       rw [Set.mem_preimage, Set.mem_singleton_iff, ‚Üê AlgEquiv.aut_one, ‚Üê AlgEquiv.aut_one,
  --         _root_.map_one]
  --     rw [WithTop.sum_eq_top]
  --     exact ‚ü®.refl, Set.mem_toFinset.mpr this, lowerIndex_refl‚ü©
  --   ¬∑ intro h
  --     rw [‚Üê ENat.coe_zero, ‚Üê ENat.some_eq_coe, WithTop.coe_eq_coe] at h
  --     apply ramificationIdx_ne_zero M L h
  ¬∑ simp only [lowerIndex_of_powerBasis y, lowerIndex_of_powerBasis x]
    simp only [hœÉ, ‚ÜìreduceDIte]
    -- let g : ((restrictNormalHom M (K‚ÇÅ := L))‚Åª¬π' {œÉ}) ‚Üí ‚Ñï‚àû := fun t => (-Multiplicative.toAdd (WithZero.unzero (val_map_powerBasis_sub_ne_zero x (preimage_nerefl œÉ hœÉ t.1 t.2)))).toNat
    rw [‚Üê Finset.sum_attach]
    conv =>
      enter [1, 2]
      ext t
      simp only [preimage_nerefl œÉ hœÉ t.1 (Set.mem_toFinset.1 t.2), ‚ÜìreduceDIte]
    rw [‚Üê ENat.coe_mul, ‚Üê Nat.cast_sum]
    apply Nat.cast_inj.2
    rw [‚Üê Nat.cast_inj (R := ‚Ñ§), Nat.cast_sum]
    conv =>
      enter [1, 2]
      ext t
      rw [Int.toNat_of_nonneg (val_mappb_sub_self_toAdd_nonpos (preimage_nerefl œÉ hœÉ t.1 (Set.mem_toFinset.mp t.2)) x), ‚Üê toAdd_inv]
    conv_rhs =>
        rw [Nat.cast_mul, Int.toNat_of_nonneg (val_mappb_sub_self_toAdd_nonpos hœÉ y), mul_comm, ‚Üê toAdd_inv, ‚Üê Int.toAdd_pow, inv_pow]
    rw [‚Üê toAdd_prod]
    apply Equiv.congr_arg
    rw [Finset.prod_inv_distrib, inv_inj, ‚Üê WithZero.coe_inj, WithZero.coe_pow, WithZero.coe_unzero, WithZero.coe_prod]
    have hy1 : (œÉ y.gen - y.gen) ‚àà vM.v.valuationSubring := by sorry
      -- apply sub_mem
      -- ¬∑ apply (mem_valuationSubring_iff v (œÉ ‚Üëy.gen)).mpr
      --   rw [val_map_le_one_iff]
      --   exact SetLike.coe_mem y.gen
      --   exact algEquiv_preserve_val_of_complete œÉ
      -- ¬∑ exact SetLike.coe_mem y.gen
    have hy2 : (‚ü®œÉ y.gen - y.gen, hy1‚ü© : vM.v.valuationSubring) ‚â† 0 := by sorry
      -- apply Subtype.coe_ne_coe.1
      -- simp only [ZeroMemClass.coe_zero]
      -- by_contra hc
      -- absurd hœÉ
      -- rw [sub_eq_zero] at hc
      -- rw [eq_iff_ValuationSubring]
      -- apply PowerBasis.algHom_ext' y
      -- rw [‚Üê Subtype.val_inj, AlgEquiv.restrictValuationSubring_apply, AlgEquiv.restrictValuationSubring_apply, coe_refl, id_eq]
      -- exact hc
    simp only [WithZero.coe_unzero, Valuation.prolongs_by_ramificationIndex hy1 hy2, ‚Üê _root_.map_prod]
    obtain ‚ü®œÄ, hpi‚ü© := exists_Uniformizer_ofDiscrete vL.v
    let a := (algebraMap M L) (œÉ ‚Üëy.gen - ‚Üëy.gen)
    let b := (‚àè x_1 ‚àà (‚áë(restrictNormalHom M (K‚ÇÅ := L)) ‚Åª¬π' {œÉ}).toFinset.attach, (x_1.1 x.gen - x.gen))
    have hr1 : a ‚àà v.valuationSubring := by sorry
    --   simp only [a]
    --   refine (mem_valuationSubring_iff v ((algebraMap M L) (œÉ ‚Üëy.gen - ‚Üëy.gen))).mpr ?_
    --   simp only [IsValExtension.val_map_le_one_iff]
    --   apply (mem_valuationSubring_iff v ((œÉ ‚Üëy.gen - ‚Üëy.gen))).mp
    --   exact hy1
    have hr1' :  (‚ü®a, hr1‚ü© : vL.v.valuationSubring) ‚â† 0 := by sorry
      -- apply Subtype.coe_ne_coe.1
      -- simp only [ZeroMemClass.coe_zero, a]
      -- apply (_root_.map_ne_zero (algebraMap M L)).mpr
      -- apply Subtype.coe_ne_coe.2 at hy2
      -- simp only [ZeroMemClass.coe_zero] at hy2
      -- exact hy2
    have hr2 : b ‚àà v.valuationSubring := by sorry
      -- simp only [b, mem_valuationSubring_iff, map_prod]
      -- apply Finset.prod_le_one
      -- exact fun i a ‚Ü¶ WithZero.zero_le (v (i.1 ‚Üëx.gen - ‚Üëx.gen))
      -- intro i hi
      -- exact val_map_sub_le_one (mem_decompositionGroup i.1) x.gen
    have hr2' :  (‚ü®b, hr2‚ü© : vL.v.valuationSubring) ‚â† 0 := by sorry
      -- apply Subtype.coe_ne_coe.1
      -- simp only [ZeroMemClass.coe_zero, b]
      -- apply Finset.prod_ne_zero_iff.2
      -- intro ‚ü®i, hi‚ü© hi1
      -- by_contra hc
      -- nth_rw 2 [‚Üê id_eq x.gen] at hc
      -- rw [sub_eq_zero, ‚Üê coe_refl (R := ùí™[K])] at hc
      -- have heq : i = .refl := by
      --   rw [eq_iff_ValuationSubring]
      --   apply PowerBasis.algHom_ext' x
      --   rw [‚Üê Subtype.val_inj, AlgEquiv.restrictValuationSubring_apply, AlgEquiv.restrictValuationSubring_apply]
      --   exact hc
      -- simp only [Set.mem_toFinset, Set.mem_preimage, Set.mem_singleton_iff] at hi
      -- absurd hœÉ
      -- rw [‚Üê hi, heq]
      -- apply (restrictNormalHom M).map_one
    obtain ‚ü®n1, u1, hnu1‚ü© := pow_Uniformizer vL.v (r := ‚ü®a, hr1‚ü©) hr1' ‚ü®œÄ, hpi‚ü©
    obtain ‚ü®n2, u2, hnu2‚ü© := pow_Uniformizer vL.v (r := ‚ü®b, hr2‚ü©) hr2' ‚ü®œÄ, hpi‚ü©
    simp only [_root_.map_sub, SubmonoidClass.coe_pow, a, b] at hnu1 hnu2
    simp only [_root_.map_sub, hnu1, hnu2, _root_.map_mul, _root_.map_pow, val_valuationSubring_unit, mul_one]
    apply congrArg
    obtain ‚ü®s, hs‚ü© := AlgEquiv.restrictNormalHom_surjective L œÉ
    let f := ‚àè t ‚àà (‚ä§ : Set (L ‚âÉ‚Çê[K] L)).toFinset, (X - C (t x.gen))
    let e : L ‚Üí+* L := {
      toFun := fun t => s t
      map_one' := map_one s
      map_mul' := AlgEquiv.map_mul' s
      map_zero' := map_zero s
      map_add' := AlgEquiv.map_add' s
    }
    let sf := Polynomial.map e f
    let sf' := ‚àè t ‚àà (‚ä§ : Set (L ‚âÉ‚Çê[K] L)).toFinset, (X - C ((s * t) x.gen))
    have hcoeff : ‚àÄ i : ‚Ñï, coeff sf i = s (coeff f i) := by sorry
      -- intro i
      -- simp only [sf, e, coeff_map, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk]
    apply le_antisymm
    ¬∑ have hab : b ‚à£ a := by
        have hy : ‚àÉ g : K[X], eval x.gen.1 (Polynomial.map (algebraMap K L) g) = algebraMap M L y.gen := by
          have hgen : adjoin K {x.gen.1} = ‚ä§ := by sorry
          obtain ‚ü®g, hg‚ü© := Algebra.exists_eq_aeval_generator hgen (algebraMap M L y.gen)
          sorry
        -- have hmin : f = Polynomial.map (algebraMap M L) (minpoly M x.gen.1) := by sorry
        obtain ‚ü®g, hg‚ü© := hy
        let g_sub_y := Polynomial.map (algebraMap K M) g - C y.gen.1
        have hdvd : minpoly M x.gen.1 ‚à£ g_sub_y := by
          apply minpoly.dvd_iff.2
          simp only [g_sub_y]
          sorry
        obtain ‚ü®h, hh‚ü© := hdvd
        have ha : a = eval x.gen.1 (Polynomial.map e (Polynomial.map (algebraMap M L) g_sub_y)) := by sorry
        have hb : b = eval x.gen.1 sf := by sorry
        rw [ha, hb]
        apply Polynomial.eval_dvd
        use Polynomial.map (algebraMap M L) h
        ext i
        simp only [coeff_map]
        sorry
      simp only [a, b, _root_.map_sub, hnu1, hnu2] at hab
      obtain ‚ü®t, ht‚ü© := hab
      have hr : t ‚àà v.valuationSubring := by sorry
      have hr' :  (‚ü®t, hr‚ü© : vL.v.valuationSubring) ‚â† 0 := by sorry
      obtain ‚ü®n, u, hnu‚ü© := pow_Uniformizer vL.v hr' ‚ü®œÄ, hpi‚ü©
      have hn : n2 + n = n1 := by sorry
      rw [‚Üê hn]
      linarith
    ¬∑ have hab : a ‚à£ b := by
        --simp only [a, b]
        have ha : a = s (algebraMap M L y.gen) - (algebraMap M L y.gen) := by sorry
        have hb : b = eval x.gen.1 (sf - f) := by sorry
        rw [ha, hb, ‚Üê eval_C (a := (s (algebraMap M L y.gen) - (algebraMap M L y.gen))) (x := x.gen.1)]
        apply Polynomial.eval_dvd
        apply (Polynomial.C_dvd_iff_dvd_coeff _ _).2
        intro i
        rw [coeff_sub, hcoeff i]
        have hdvd : (algebraMap M L y.gen) ‚à£ f.coeff i := by sorry
        obtain ‚ü®t, ht‚ü© := hdvd
        have ht' : s (f.coeff i) = s ((algebraMap M L) y.gen) * t := by sorry
        use t
        nth_rw 2 [ht]
        rw [ht', sub_mul]
      simp only [a, b, _root_.map_sub, hnu1, hnu2] at hab
      obtain ‚ü®t, ht‚ü© := hab

      sorry
    -- have : ‚àë x : ((restrictNormalHom M)‚Åª¬π' {œÉ}), g x = ‚Üë(ramificationIdx M L) * ‚Üë(-Multiplicative.toAdd (WithZero.unzero (val_map_powerBasis_sub_ne_zero y (of_eq_false (eq_false hœÉ))))).toNat := by
    --   unfold g
    --   rw [‚Üê ENat.coe_mul, ‚Üê Nat.cast_sum]
    --   apply Nat.cast_inj.mpr ?_
    --   rw [‚Üê Nat.cast_inj (R := ‚Ñ§)]
    --   have h1 : 0 ‚â§ -Multiplicative.toAdd (WithZero.unzero (val_map_powerBasis_sub_ne_zero y (of_eq_false (eq_false hœÉ)))) := by sorry
    --   have h2 : ‚àÄ t : ((restrictNormalHom M)‚Åª¬π' {œÉ}), 0 ‚â§ -Multiplicative.toAdd (WithZero.unzero (val_map_powerBasis_sub_ne_zero x (preimage_nerefl œÉ hœÉ t.1 t.2))) := by sorry
    --   conv =>
    --     right
    --     rw [Nat.cast_mul, Int.toNat_of_nonneg h1, mul_comm, ‚Üê toAdd_inv, ‚Üê Int.toAdd_pow, inv_pow, toAdd_inv]
    --   rw [Nat.cast_sum]
    --   conv =>
    --     enter [1, 2]
    --     ext t
    --     rw [Int.toNat_of_nonneg (h2 t)]
    --   #check Finset.sum_attach_univ
    --   #check Finset.attach ((restrictNormalHom M) ‚Åª¬π' {œÉ}).toFinset
    --   sorry

#help tactic conv

    /- Need:
    2. all valuations are discrete
    3. ùí™[L] / ùí™[M] admits a power basis b, so that the minpoly of b over M has coeff in ùí™[M]
    -/


end sum_lowerIndex

section aux

variable {K K' L : Type*} {ŒìK : outParam Type*} [Field K] [Field K'] [Field L] [vK' : Valued K' ‚Ñ§‚Çò‚ÇÄ] [vL : Valued L ‚Ñ§‚Çò‚ÇÄ] [IsDiscrete vK'.v] [IsDiscrete vL.v] [Algebra K L] [Algebra K K'] [Algebra K' L] [IsScalarTower K K' L] [IsValExtension K' L] [Normal K K'] [Normal K L] [FiniteDimensional K L] [FiniteDimensional K K']
